<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Electric Field Hockey</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:ital,wght@0,300;0,400;0,600;1,300&display=swap"
      rel="stylesheet"
    />
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      :root {
        --bg: #060a14;
        --panel: #0c1220;
        --panel-border: #1a2540;
        --accent: #00ccff;
        --accent-dim: #00ccff44;
        --positive: #ff3355;
        --positive-glow: #ff335566;
        --negative: #3388ff;
        --negative-glow: #3388ff66;
        --puck: #00ff88;
        --puck-glow: #00ff8866;
        --goal: #ffd700;
        --text: #c8d6e8;
        --text-dim: #5a6d88;
        --text-muted: #354050;
        --wall-color: #8899bb;
        --success: #00ff88;
        --radius: 8px;
      }

      body {
        background: var(--bg);
        color: var(--text);
        font-family: "Exo 2", sans-serif;
        overflow: hidden;
        height: 100vh;
        width: 100vw;
        display: flex;
        flex-direction: column;
        user-select: none;
        -webkit-user-select: none;
      }

      /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         HEADER - Navigation bar
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
      header {
        display: flex;
        align-items: center;
        gap: 16px;
        padding: 8px 16px;
        background: linear-gradient(180deg, #0d1525 0%, var(--bg) 100%);
        border-bottom: 1px solid var(--panel-border);
        flex-shrink: 0;
        min-height: 44px;
      }
      .back-btn {
        background: none;
        border: none;
        color: var(--text-dim);
        font-size: 20px;
        cursor: pointer;
        padding: 4px 8px;
        line-height: 1;
      }
      .back-btn:hover { color: var(--accent); }
      header h1 {
        font-family: "Orbitron", monospace;
        font-size: 16px;
        font-weight: 700;
        letter-spacing: 2px;
        background: linear-gradient(135deg, var(--accent), #66eeff);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        white-space: nowrap;
      }
      header .status {
        font-family: "Orbitron", monospace;
        font-size: 11px;
        padding: 4px 10px;
        border-radius: 20px;
        border: 1px solid var(--panel-border);
        background: var(--panel);
        white-space: nowrap;
      }
      header .status.running { border-color: var(--puck); color: var(--puck); }
      header .status.won { border-color: var(--goal); color: var(--goal); }
      .header-spacer { flex: 1; }
      .lang-switch {
        font-family: "Orbitron", monospace;
        font-size: 11px;
        letter-spacing: 1px;
        display: flex;
        align-items: center;
      }
      .lang-switch button {
        background: none;
        border: none;
        color: var(--text-muted);
        cursor: pointer;
        padding: 4px 6px;
        transition: color 0.2s;
        font-family: inherit;
        font-size: inherit;
      }
      .lang-switch button:hover { color: var(--text-dim); }
      .lang-switch button.active { color: var(--accent); }
      .lang-switch .lang-sep { color: var(--text-muted); }

      /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         CONTROL BAR - Horizontal controls (Desktop)
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
      .control-bar {
        display: flex;
        justify-content: center;
        align-items: stretch;
        gap: 6px;
        padding: 8px 12px;
        background: var(--panel);
        border-bottom: 1px solid var(--panel-border);
        flex-shrink: 0;
        overflow-x: auto;
      }
      .control-panel {
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid var(--panel-border);
        border-radius: var(--radius);
        padding: 8px 10px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .control-panel h3 {
        font-family: "Orbitron", monospace;
        font-size: 9px;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        color: var(--accent);
        margin: 0;
        white-space: nowrap;
      }
      .control-panel .btn-group {
        display: flex;
        gap: 3px;
      }
      .control-panel .btn-group button {
        padding: 5px 8px;
        font-size: 11px;
      }
      .slider-row {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .slider-row input[type="range"] {
        width: 70px;
        accent-color: var(--accent);
        height: 4px;
      }
      .slider-row .slider-val {
        font-family: "Orbitron", monospace;
        font-size: 10px;
        min-width: 22px;
        text-align: right;
        color: var(--accent);
      }
      .checkbox-row {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 11px;
        color: var(--text-dim);
        cursor: pointer;
        white-space: nowrap;
      }
      .checkbox-row:hover { color: var(--text); }
      .checkbox-row input[type="checkbox"] {
        accent-color: var(--accent);
        width: 13px;
        height: 13px;
      }
      .control-panel .controls-row {
        display: flex;
        gap: 3px;
      }
      .charge-count {
        font-size: 10px;
        color: var(--text-dim);
        white-space: nowrap;
      }
      .charge-count span { color: var(--accent); }

      /* Buttons */
      button {
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        border: 1px solid var(--panel-border);
        border-radius: 6px;
        padding: 6px 10px;
        font-family: "Exo 2", sans-serif;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.15s;
        white-space: nowrap;
      }
      button:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: var(--accent);
      }
      button.active {
        background: var(--accent-dim);
        border-color: var(--accent);
        color: #fff;
      }
      button.active-pos {
        background: var(--positive-glow);
        border-color: var(--positive);
        color: #fff;
      }
      button.active-neg {
        background: var(--negative-glow);
        border-color: var(--negative);
        color: #fff;
      }
      button.primary {
        background: var(--accent-dim);
        border-color: var(--accent);
        color: #fff;
        font-weight: 600;
        padding: 8px 14px;
        font-size: 12px;
        letter-spacing: 1px;
      }
      button.primary:hover {
        background: rgba(0, 204, 255, 0.3);
      }

      /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         MOBILE HEADER - Compact icons
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
      .mobile-control-bar {
        display: none;
        justify-content: center;
        align-items: center;
        gap: 5px;
        padding: 8px 10px;
        background: var(--panel);
        border-bottom: 1px solid var(--panel-border);
        flex-shrink: 0;
      }
      .mobile-control-bar .icon-btn {
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        padding: 0;
        border-radius: 8px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid var(--panel-border);
        transition: all 0.2s;
      }
      .mobile-control-bar .icon-btn.active {
        background: var(--accent-dim);
        border-color: var(--accent);
        box-shadow: 0 0 12px var(--accent-dim);
      }

      /* Level buttons - compact style */
      .mobile-control-bar .level-btn {
        font-family: "Orbitron", monospace;
        font-size: 12px;
        font-weight: bold;
        width: 32px;
        height: 32px;
      }
      .mobile-control-bar .level-btn.active {
        background: var(--accent-dim);
        border-color: var(--accent);
        color: #fff;
        box-shadow: 0 0 8px var(--accent-dim);
      }

      /* Mode buttons */
      .mobile-control-bar .mode-btn {
        font-family: "Orbitron", monospace;
        font-size: 11px;
        font-weight: bold;
        width: 32px;
        height: 32px;
      }

      /* Charge buttons - glowing orb style */
      .mobile-control-bar .charge-icon {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        position: relative;
        border: none;
        background: transparent;
      }
      .mobile-control-bar .charge-icon::before {
        content: '';
        position: absolute;
        inset: 4px;
        border-radius: 50%;
        transition: all 0.2s;
      }
      .mobile-control-bar .charge-icon::after {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 50%;
        opacity: 0.3;
        transition: all 0.2s;
      }
      .mobile-control-bar .charge-icon .charge-symbol {
        position: relative;
        z-index: 1;
        font-weight: bold;
        font-size: 18px;
        text-shadow: 0 0 6px currentColor;
      }

      /* Positive charge icon */
      .mobile-control-bar .charge-icon.pos-icon {
        color: var(--positive);
      }
      .mobile-control-bar .charge-icon.pos-icon::before {
        background: radial-gradient(circle at 35% 35%, rgba(255,150,170,0.6) 0%, rgba(255,51,85,0.3) 50%, transparent 70%);
        border: 2px solid var(--positive);
        opacity: 0.5;
      }
      .mobile-control-bar .charge-icon.pos-icon::after {
        box-shadow: 0 0 15px var(--positive), inset 0 0 10px rgba(255,51,85,0.2);
        opacity: 0.3;
      }
      .mobile-control-bar .charge-icon.pos-icon.active-pos::before {
        opacity: 1;
        box-shadow: 0 0 8px var(--positive);
      }
      .mobile-control-bar .charge-icon.pos-icon.active-pos::after {
        opacity: 0.6;
        box-shadow: 0 0 20px var(--positive), 0 0 30px var(--positive-glow);
      }

      /* Negative charge icon */
      .mobile-control-bar .charge-icon.neg-icon {
        color: var(--negative);
      }
      .mobile-control-bar .charge-icon.neg-icon::before {
        background: radial-gradient(circle at 35% 35%, rgba(150,180,255,0.6) 0%, rgba(51,136,255,0.3) 50%, transparent 70%);
        border: 2px solid var(--negative);
        opacity: 0.5;
      }
      .mobile-control-bar .charge-icon.neg-icon::after {
        box-shadow: 0 0 15px var(--negative), inset 0 0 10px rgba(51,136,255,0.2);
        opacity: 0.3;
      }
      .mobile-control-bar .charge-icon.neg-icon.active-neg::before {
        opacity: 1;
        box-shadow: 0 0 8px var(--negative);
      }
      .mobile-control-bar .charge-icon.neg-icon.active-neg::after {
        opacity: 0.6;
        box-shadow: 0 0 20px var(--negative), 0 0 30px var(--negative-glow);
      }

      .mobile-control-bar .separator {
        width: 1px;
        height: 28px;
        background: var(--panel-border);
        margin: 0 3px;
        flex-shrink: 0;
      }
      .mobile-control-bar .back-icon {
        font-size: 18px;
        color: var(--text-dim);
        width: 36px;
      }
      .mobile-control-bar .back-icon:hover {
        color: var(--accent);
      }

      /* Header groups - for alignment with drawer */
      .mobile-control-bar .header-group {
        display: flex;
        align-items: center;
        gap: 2px;
      }

      /* Puck icon in header */
      .mobile-control-bar .puck-icon {
        color: var(--puck);
        font-size: 14px;
        text-shadow: 0 0 6px var(--puck);
        margin-right: 4px;
      }

      /* Value displays - clickable numbers */
      .mobile-control-bar .value-display {
        font-family: "Orbitron", monospace;
        font-size: 11px;
        color: var(--accent);
        padding: 3px 6px;
        background: rgba(0, 204, 255, 0.1);
        border: 1px solid var(--panel-border);
        border-radius: 4px;
        cursor: pointer;
        min-width: 24px;
        text-align: center;
        transition: all 0.15s;
      }
      .mobile-control-bar .value-display:hover {
        border-color: var(--accent);
        background: rgba(0, 204, 255, 0.2);
      }
      .mobile-control-bar .value-display.puck-value {
        color: var(--puck);
        background: rgba(0, 255, 136, 0.1);
      }
      .mobile-control-bar .value-display.puck-value:hover {
        border-color: var(--puck);
        background: rgba(0, 255, 136, 0.2);
      }

      /* Mobile language switch */
      .mobile-lang-switch {
        display: flex;
        align-items: center;
        font-family: "Orbitron", monospace;
        font-size: 10px;
        letter-spacing: 0.5px;
      }
      .mobile-lang-switch button {
        background: none;
        border: none;
        color: var(--text-muted);
        cursor: pointer;
        padding: 4px 4px;
        font-family: inherit;
        font-size: inherit;
        transition: color 0.2s;
      }
      .mobile-lang-switch button:hover { color: var(--text-dim); }
      .mobile-lang-switch button.active { color: var(--accent); }
      .mobile-lang-switch .lang-sep { color: var(--text-muted); font-size: 9px; }
      .drawer-toggle {
        margin-left: 4px;
      }

      /* Custom SVG icons for mobile - improved */
      .icon-trajectory, .icon-field {
        width: 22px;
        height: 22px;
      }

      /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         MOBILE DRAWER - Aligned with header groups
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
      .mobile-drawer {
        display: none;
        justify-content: center;
        align-items: stretch;
        gap: 0;
        padding: 8px 10px;
        background: var(--panel);
        border-bottom: 1px solid var(--panel-border);
        flex-shrink: 0;
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transition: max-height 0.3s ease, opacity 0.2s ease, padding 0.3s ease;
      }
      .mobile-drawer.open {
        max-height: 200px;
        opacity: 1;
      }

      /* Drawer spacers - match header items with no drawer content */
      .drawer-spacer {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      .drawer-spacer.back-spacer { width: 36px; }
      .drawer-spacer.lang-spacer { width: 76px; }

      /* Drawer sections - aligned below header groups */
      .drawer-section {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 3px;
        padding: 4px 6px;
        min-height: 50px;
        flex-shrink: 0;
      }
      .drawer-section .section-label {
        font-family: "Orbitron", monospace;
        font-size: 8px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--accent);
        white-space: nowrap;
        opacity: 0.8;
      }
      .drawer-section .section-value {
        font-family: "Orbitron", monospace;
        font-size: 12px;
        color: var(--text);
        font-weight: bold;
      }

      /* Levels section - matches header: 4 level buttons (32px each) + gaps */
      .drawer-section.levels-section {
        width: 138px;
      }

      /* Mode section - matches header: 2 mode buttons (32px each) + gap */
      .drawer-section.mode-section {
        width: 70px;
      }
      .drawer-section.mode-section .mode-label {
        color: var(--puck);
        font-weight: bold;
      }

      /* Charge count section - matches header: 2 orbs (40px each) + value (28px) + gaps */
      .drawer-section.charges-section {
        width: 116px;
        cursor: pointer;
      }
      .drawer-section.charges-section:hover {
        background: rgba(0, 204, 255, 0.05);
      }

      /* Puck settings section - matches header: puck icon + value display */
      .drawer-section.puck-section {
        width: 70px;
        gap: 4px;
      }
      .drawer-section.puck-section .slider-compact {
        width: 100%;
        display: flex;
        align-items: center;
        gap: 3px;
      }
      .drawer-section.puck-section .slider-label {
        font-family: "Orbitron", monospace;
        font-size: 9px;
        color: var(--puck);
        min-width: 10px;
        opacity: 0.7;
      }
      .drawer-section.puck-section input[type="range"] {
        width: 35px;
        accent-color: var(--puck);
        height: 4px;
      }
      .drawer-section.puck-section .slider-val {
        font-family: "Orbitron", monospace;
        font-size: 9px;
        color: var(--puck);
        min-width: 16px;
        text-align: right;
      }

      /* Display labels section - matches header: 3 display icons (36px each) + gaps */
      .drawer-section.display-section {
        flex-direction: column;
        gap: 2px;
        width: 116px;
      }
      .drawer-section.display-section .display-label {
        font-size: 8px;
        color: var(--text-dim);
        padding: 3px 6px;
        border-radius: 3px;
        background: transparent;
        cursor: pointer;
        white-space: nowrap;
        transition: all 0.15s;
        text-align: center;
      }
      .drawer-section.display-section .display-label:hover {
        color: var(--text);
      }
      .drawer-section.display-section .display-label.active {
        color: var(--accent);
        background: var(--accent-dim);
      }

      /* Controls section - matches header: 3 control buttons (36px each) + gaps */
      .drawer-section.controls-section {
        width: 116px;
      }

      /* Separator in drawer - same spacing as header */
      .drawer-separator {
        width: 1px;
        background: var(--panel-border);
        align-self: stretch;
        margin: 0 3px;
        flex-shrink: 0;
      }
      /* Match header separator spacing */
      .mobile-control-bar .separator {
        margin: 0 3px;
      }

      /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         CANVAS AREA
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
      #main {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        position: relative;
      }
      #canvas-wrap {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 12px;
        position: relative;
        overflow: hidden;
      }
      canvas {
        display: block;
        border-radius: 6px;
        box-shadow:
          0 0 40px rgba(0, 204, 255, 0.05),
          0 0 1px rgba(0, 204, 255, 0.3);
        cursor: crosshair;
      }

      /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         RESPONSIVE - Mobile
         â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
      @media (max-width: 900px) {
        header { display: none; }
        .control-bar { display: none; }
        .mobile-control-bar { display: flex; }
        .mobile-drawer { display: flex; }
        #canvas-wrap { padding: 6px; }
      }
    </style>
  </head>
  <body>
    <!-- Header Navigation -->
    <header>
      <button class="back-btn" onclick="location.href='index.html'" title="Back">â†</button>
      <h1 data-i18n="heading">âš¡ ELECTRIC FIELD HOCKEY</h1>
      <span class="status" id="statusBadge" data-i18n="setup">SETUP</span>
      <span class="header-spacer"></span>
      <div class="lang-switch">
        <button data-lang="lv">LV</button>
        <span class="lang-sep">|</span>
        <button data-lang="en">EN</button>
      </div>
    </header>

    <!-- Desktop Control Bar (horizontal, full controls) -->
    <div class="control-bar">
      <!-- Difficulty & Mode -->
      <div class="control-panel">
        <h3 data-i18n="difficulty">Difficulty</h3>
        <div class="btn-group" id="levelBtns">
          <button class="active" data-level="practice" data-i18n="practice">Practice</button>
          <button data-level="1" data-i18n="level1">Level 1</button>
          <button data-level="2" data-i18n="level2">Level 2</button>
          <button data-level="3" data-i18n="level3">Level 3</button>
        </div>
        <h3 data-i18n="gameMode" style="margin-top: 6px">Game Mode</h3>
        <div class="btn-group" id="modeBtns">
          <button class="active" data-mode="easy" data-i18n="easyMode">Easy</button>
          <button data-mode="hard" data-i18n="hardMode">Hard</button>
        </div>
      </div>

      <!-- Charge Selection -->
      <div class="control-panel">
        <h3 data-i18n="placeCharge">Place Charge</h3>
        <div class="btn-group" id="chargeBtns">
          <button class="active-pos" data-charge="+1" data-i18n="positive">âŠ• Positive</button>
          <button data-charge="-1" data-i18n="negative">âŠ– Negative</button>
        </div>
        <div class="charge-count">
          <span data-i18n="chargesPlaced">Charges:</span>
          <span id="chargeCount">0</span>
        </div>
      </div>

      <!-- Puck Settings -->
      <div class="control-panel">
        <h3 data-i18n="puckMass">Puck Mass</h3>
        <div class="slider-row">
          <input type="range" id="massSlider" min="1" max="100" value="25" />
          <span class="slider-val" id="massVal">25</span>
        </div>
        <h3 data-i18n="puckCharge" style="margin-top: 6px">Puck Charge</h3>
        <div class="slider-row">
          <input type="range" id="chargeSlider" min="-10" max="10" value="5" />
          <span class="slider-val" id="chargeVal">+5</span>
        </div>
      </div>

      <!-- Display Options -->
      <div class="control-panel">
        <h3 data-i18n="display">Display</h3>
        <label class="checkbox-row"><input type="checkbox" id="chkField" /><span data-i18n="electricField">Electric Field</span></label>
        <label class="checkbox-row"><input type="checkbox" id="chkTrace" checked /><span data-i18n="puckTrace">Puck Trace</span></label>
        <label class="checkbox-row"><input type="checkbox" id="chkForce" checked /><span data-i18n="forceArrow">Force Arrow</span></label>
      </div>

      <!-- Game Controls -->
      <div class="control-panel">
        <h3 data-i18n="controls">Controls</h3>
        <button class="primary" id="btnStart" data-i18n="start">â–¶ START</button>
        <div class="controls-row" style="margin-top: 4px">
          <button id="btnReset" data-i18n="reset">â†º Reset</button>
          <button id="btnClear" data-i18n="clear">âœ• Clear</button>
        </div>
      </div>
    </div>

    <!-- Mobile Control Bar - Single header with all controls -->
    <div class="mobile-control-bar" id="mobileControlBar">
      <!-- Back button -->
      <button class="icon-btn back-icon" onclick="location.href='index.html'" title="Back">â†</button>
      <span class="separator"></span>
      <!-- Level buttons -->
      <div class="header-group" id="headerLevels">
        <button class="icon-btn level-btn active" data-level="practice" title="Practice" id="mLevelP">T</button>
        <button class="icon-btn level-btn" data-level="1" title="Level 1" id="mLevel1">1</button>
        <button class="icon-btn level-btn" data-level="2" title="Level 2" id="mLevel2">2</button>
        <button class="icon-btn level-btn" data-level="3" title="Level 3" id="mLevel3">3</button>
      </div>
      <span class="separator"></span>
      <!-- Mode -->
      <div class="header-group" id="headerMode">
        <button class="icon-btn mode-btn active" id="mModeEasy" title="Easy">E</button>
        <button class="icon-btn mode-btn" id="mModeHard" title="Hard">H</button>
      </div>
      <span class="separator"></span>
      <!-- Charge selection - glowing orbs -->
      <div class="header-group" id="headerCharges">
        <button class="charge-icon pos-icon active-pos" id="mChargePos" title="Positive">
          <span class="charge-symbol">+</span>
        </button>
        <button class="charge-icon neg-icon" id="mChargeNeg" title="Negative">
          <span class="charge-symbol">âˆ’</span>
        </button>
        <span class="value-display" id="mChargeCountBtn" title="Charges placed">0</span>
      </div>
      <span class="separator"></span>
      <!-- Puck values with icon -->
      <div class="header-group" id="headerPuck">
        <span class="puck-icon">â—</span>
        <span class="value-display puck-value" id="mPuckValueBtn" title="Puck m/q">25/+5</span>
      </div>
      <span class="separator"></span>
      <!-- Display toggles -->
      <div class="header-group" id="headerDisplay">
        <button class="icon-btn" id="mField" title="Electric Field">
          <svg class="icon-field" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8">
            <path d="M4 12h12" stroke-linecap="round"/>
            <path d="M12 8l4 4-4 4" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M4 6h9" stroke-linecap="round" opacity="0.6"/>
            <path d="M10 3l3 3-3 3" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/>
            <path d="M4 18h9" stroke-linecap="round" opacity="0.6"/>
            <path d="M10 15l3 3-3 3" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/>
          </svg>
        </button>
        <button class="icon-btn active" id="mTrace" title="Trajectory">
          <svg class="icon-trajectory" viewBox="0 0 24 24" fill="none" stroke="var(--puck)" stroke-width="2">
            <path d="M4 18 Q10 4, 20 12" stroke-linecap="round"/>
            <circle cx="4" cy="18" r="3" fill="var(--puck)" stroke="none"/>
            <path d="M16 10l4 2-2 4" stroke-linecap="round" stroke-linejoin="round" opacity="0.7"/>
          </svg>
        </button>
        <button class="icon-btn active" id="mForce" title="Force">
          <svg viewBox="0 0 24 24" width="22" height="22" fill="none" stroke="#ffcc00" stroke-width="2.5">
            <path d="M6 12h10" stroke-linecap="round"/>
            <path d="M12 7l5 5-5 5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
      </div>
      <span class="separator"></span>
      <!-- Controls -->
      <div class="header-group" id="headerControls">
        <button class="icon-btn primary" id="mStart" title="Start">â–¶</button>
        <button class="icon-btn" id="mReset" title="Reset">â†º</button>
        <button class="icon-btn" id="mClear" title="Clear">âœ•</button>
      </div>
      <span class="separator"></span>
      <!-- Language switch -->
      <div class="mobile-lang-switch">
        <button data-lang="lv">LV</button>
        <span class="lang-sep">|</span>
        <button data-lang="en">EN</button>
      </div>
      <!-- Drawer toggle -->
      <button class="icon-btn drawer-toggle" id="drawerToggle" title="Settings">â–¼</button>
    </div>

    <!-- Mobile Drawer - sections aligned exactly below header groups -->
    <div class="mobile-drawer" id="mobileDrawer">
      <!-- Spacer for back button -->
      <div class="drawer-spacer back-spacer"></div>
      <span class="drawer-separator"></span>
      <!-- Levels label -->
      <div class="drawer-section levels-section" id="drawerLevels">
        <span class="section-label" data-i18n="difficulty">LÄ«meÅ†i</span>
      </div>
      <span class="drawer-separator"></span>
      <!-- Mode label -->
      <div class="drawer-section mode-section" id="drawerMode">
        <span class="section-label mode-label" id="mModeLabel">Viegls</span>
      </div>
      <span class="drawer-separator"></span>
      <!-- Charges section -->
      <div class="drawer-section charges-section" id="drawerCharges">
        <span class="section-label" data-i18n="placeCharge">LÄdiÅ†i</span>
        <span class="section-value" id="mChargeCount">0</span>
      </div>
      <span class="drawer-separator"></span>
      <!-- Puck sliders section -->
      <div class="drawer-section puck-section" id="drawerPuck">
        <div class="slider-compact">
          <span class="slider-label">m</span>
          <input type="range" id="mMassSlider" min="1" max="100" value="25" />
          <span class="slider-val" id="mMassVal">25</span>
        </div>
        <div class="slider-compact">
          <span class="slider-label">q</span>
          <input type="range" id="mChargeSlider" min="-10" max="10" value="5" />
          <span class="slider-val" id="mChargeVal">+5</span>
        </div>
      </div>
      <span class="drawer-separator"></span>
      <!-- Display labels -->
      <div class="drawer-section display-section" id="drawerDisplay">
        <span class="display-label" id="mLabelField">Vektori</span>
        <span class="display-label active" id="mLabelTrace">Trajekt.</span>
        <span class="display-label active" id="mLabelForce">SpÄ“ks</span>
      </div>
      <span class="drawer-separator"></span>
      <!-- Controls label -->
      <div class="drawer-section controls-section" id="drawerControlsLabel">
        <span class="section-label" data-i18n="controls">Kontrole</span>
      </div>
      <span class="drawer-separator"></span>
      <!-- Spacer for lang/toggle -->
      <div class="drawer-spacer lang-spacer"></div>
    </div>

    <div id="main">
      <div id="canvas-wrap">
        <canvas id="gameCanvas"></canvas>
      </div>
    </div>

    <script>
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  TRANSLATIONS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const TRANSLATIONS = {
        en: {
          title: "Electric Field Hockey",
          heading: "âš¡ ELECTRIC FIELD HOCKEY",
          subtitle: "Place charges to guide the puck into the goal",
          difficulty: "Difficulty",
          gameMode: "Game Mode",
          easyMode: "Easy",
          hardMode: "Hard",
          placeCharge: "Place Charge",
          puckMass: "Puck Mass",
          puckCharge: "Puck Charge",
          display: "Display",
          controls: "Controls",
          howToPlay: "How to Play",
          practice: "Practice",
          practiceShort: "T.",
          level1: "Level 1",
          level1Short: "1.",
          level2: "Level 2",
          level2Short: "2.",
          level3: "Level 3",
          level3Short: "3.",
          positive: "âŠ• Positive",
          negative: "âŠ– Negative",
          start: "â–¶ START",
          pause: "â¸ PAUSE",
          resume: "â–¶ RESUME",
          reset: "â†º Reset",
          clear: "âœ• Clear",
          chargesPlaced: "Charges placed:",
          electricField: "Electric Field",
          puckTrace: "Puck Trace",
          forceArrow: "Force Arrow",
          helpClick: "Click on the field to place charges.",
          helpDrag: "Drag charges to move them.",
          helpRemove: "Right-click a charge to remove it.",
          helpSpace: "Press <kbd>Space</kbd> to start/pause.",
          setup: "SETUP",
          running: "RUNNING",
          paused: "PAUSED",
          goalStatus: "ğŸ‰ GOAL!",
          goalLabel: "GOAL",
          goalText: "GOAL!",
          outOfBounds: "PUCK OVERBOARD!",
          playAgain: "[ Space ]",
        },
        lv: {
          title: "ElektriskÄ lauka hokejs",
          heading: "âš¡ ELEKTRISKÄ€ LAUKA HOKEJS",
          subtitle: "Novieto lÄdiÅ†us, lai vadÄ«tu ripu vÄrtos!",
          difficulty: "GrÅ«tÄ«bas pakÄpe",
          gameMode: "SpÄ“les reÅ¾Ä«ms",
          easyMode: "Viegls",
          hardMode: "GrÅ«ts",
          placeCharge: "Novietot lÄdiÅ†u",
          puckMass: "Ripas masa",
          puckCharge: "Ripas lÄdiÅ†Å¡",
          display: "RÄdÄ«t",
          controls: "Kontrole",
          howToPlay: "KÄ spÄ“lÄ“t",
          practice: "TreniÅ†Å¡",
          practiceShort: "T.",
          level1: "1. lÄ«menis",
          level1Short: "1.",
          level2: "2. lÄ«menis",
          level2Short: "2.",
          level3: "3. lÄ«menis",
          level3Short: "3.",
          positive: "âŠ• PozitÄ«vs",
          negative: "âŠ– NegatÄ«vs",
          start: "â–¶ SÄ€KT",
          pause: "â¸ PAUZE",
          resume: "â–¶ TURPINÄ€T",
          reset: "â†º No jauna",
          clear: "âœ• NotÄ«rÄ«t",
          chargesPlaced: "LÄdiÅ†u skaits:",
          electricField: "Elektriskais lauks",
          puckTrace: "Ripas trajektorija",
          forceArrow: "SpÄ“ka vektors",
          helpClick: "NoklikÅ¡Ä·ini uz laukuma, lai novietotu lÄdiÅ†us.",
          helpDrag: "Velc lÄdiÅ†us, lai tos pÄrvietotu.",
          helpRemove: "Ar labo klikÅ¡Ä·i noÅ†em lÄdiÅ†u.",
          helpSpace: "Spied <kbd>Space</kbd>, lai sÄktu/iepauzÄ“tu.",
          setup: "SAGATAVOÅ ANÄ€S",
          running: "DARBÄªBÄ€",
          paused: "PAUZE",
          goalStatus: "ğŸ‰ VÄ€RTI!",
          goalLabel: "VÄ€RTI",
          goalText: "VÄ€RTI!",
          outOfBounds: "RIPA PÄ€RI BORTAM!",
          playAgain: "[ Space ]",
        },
      };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  LANGUAGE SWITCH
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function getDefaultLang() {
        const saved = localStorage.getItem("physics-sims-lang");
        if (saved) return saved;
        const browserLang = navigator.language.toLowerCase();
        return browserLang.startsWith("lv") ? "lv" : "en";
      }

      let currentLang = getDefaultLang();

      function setLanguage(lang) {
        currentLang = lang;
        localStorage.setItem("physics-sims-lang", lang);

        document.querySelectorAll("[data-i18n]").forEach((el) => {
          const key = el.dataset.i18n;
          if (TRANSLATIONS[lang][key]) {
            el.innerHTML = TRANSLATIONS[lang][key];
          }
        });

        if (TRANSLATIONS[lang].title) {
          document.title = TRANSLATIONS[lang].title;
        }

        document.querySelectorAll(".lang-switch button, .mobile-lang-switch button").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.lang === lang);
        });

        document.documentElement.lang = lang;

        // Update dynamic UI elements
        updateUI();
        // Update desktop level button text for current selection
        if (typeof updateDesktopLevelText === "function") {
          updateDesktopLevelText(currentLevel);
        }
      }

      function initLanguage() {
        setLanguage(currentLang);
        document.querySelectorAll(".lang-switch button").forEach((btn) => {
          btn.addEventListener("click", () => setLanguage(btn.dataset.lang));
        });
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  CONFIGURATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const FIELD_W = 880;
      const FIELD_H = 560;
      const PUCK_R = 13;
      const CHARGE_R = 16;
      const GOAL_OPENING = 110;
      const GOAL_DEPTH = 36;
      const WALL_T = 8;

      // Physics (tuned for fun gameplay)
      const COULOMB_K = 1000000;
      const MIN_DIST = 22;
      const BOUNCE_COEFF = 0.88;
      const MAX_SPEED = 2500;
      const SUB_STEPS = 20;
      const DT = 1 / 60;

      // Physics field is 2x bigger than visible field (centered)
      // Puck can move freely outside visible area, but resets if exits physics field
      const PHYSICS_FIELD_W = FIELD_W * 2;
      const PHYSICS_FIELD_H = FIELD_H * 2;
      const PHYSICS_OFFSET_X = -FIELD_W / 2; // left edge of physics field
      const PHYSICS_OFFSET_Y = -FIELD_H / 2; // top edge of physics field

      // Charge placement area extends beyond visible field by 1.2x charge diameter
      const CHARGE_MARGIN = CHARGE_R * 2 * 1.2; // ~38 pixels

      // Visual margin to show charges placed outside field (top/bottom)
      const VISUAL_MARGIN = 40;

      // Colors
      const COL = {
        bg: "#080d18",
        grid: "rgba(100,160,255,0.04)",
        wall: "#6878a0",
        wallGlow: "rgba(100,130,200,0.15)",
        goalFill: "rgba(255,215,0,0.08)",
        goalBorder: "#ffd700",
        goalNet: "rgba(255,215,0,0.25)",
        positive: "#ff3355",
        posBright: "#ff6b8a",
        posGlow: "rgba(255,51,85,0.35)",
        posCore: "rgba(255,150,170,0.8)",
        negative: "#3388ff",
        negBright: "#6ba3ff",
        negGlow: "rgba(51,136,255,0.35)",
        negCore: "rgba(150,180,255,0.8)",
        puck: "#00ff88",
        puckGlow: "rgba(0,255,136,0.4)",
        trail: "rgba(0,255,136,",
        fieldArrow: "rgba(100,200,255,0.2)",
        forceArrow: "#ffcc00",
      };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  LEVEL DEFINITIONS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Walls defined as {x, y, w, h} rectangles
      function makeLevelWalls(level) {
        const walls = [];
        const cw = FIELD_W,
          ch = FIELD_H;
        switch (level) {
          case "practice":
            // No internal walls
            break;
          case "1":
            // Single vertical line in center, length = 2x goal width
            const wallLen1 = GOAL_OPENING * 2;
            walls.push({ x: cw * 0.5, y: (ch - wallLen1) / 2, w: WALL_T, h: wallLen1 });
            break;
          case "2":
            // Two barriers forming a chicane
            walls.push({ x: cw * 0.35, y: 0, w: WALL_T, h: ch * 0.65 });
            walls.push({ x: cw * 0.62, y: ch * 0.35, w: WALL_T, h: ch * 0.65 });
            break;
          case "3":
            // Three barriers - maze-like
            walls.push({ x: cw * 0.25, y: 0, w: WALL_T, h: ch * 0.6 });
            walls.push({ x: cw * 0.48, y: ch * 0.3, w: WALL_T, h: ch * 0.7 });
            walls.push({ x: cw * 0.71, y: 0, w: WALL_T, h: ch * 0.55 });
            break;
        }
        return walls;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  GAME STATE
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      let scale = 1;
      let offsetX = 0,
        offsetY = 0;

      // State
      let gameState = "setup"; // setup | running | paused | won
      let currentLevel = "practice";
      let puckMass = 25;
      let puckCharge = 5;
      let selectedCharge = +1;
      let showField = false;
      let showTrace = true;
      let showForce = true;
      let hardMode = false;

      // Objects
      let puck = null;
      let charges = [];
      let walls = [];
      let trail = [];
      let particles = []; // celebration particles
      let fieldCache = null;
      let fieldCacheDirty = true;
      let oobFlashTimer = 0; // out-of-bounds flash timer

      // Interaction
      let dragTarget = null; // { type:'charge', index } or null
      let mouseField = { x: -1, y: -1 }; // mouse position in field coordinates
      let mouseOnField = false;

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  INITIALIZATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function resetPuck() {
        puck = {
          x: FIELD_W * 0.12,
          y: FIELD_H / 2,
          vx: 0,
          vy: 0,
          charge: puckCharge,
          radius: PUCK_R,
        };
        trail = [];
      }

      function initLevel(level) {
        currentLevel = level;
        walls = makeLevelWalls(level);
        resetPuck();
        gameState = "setup";
        particles = [];
        fieldCacheDirty = true;
        updateUI();
      }

      function resizeCanvas() {
        const wrap = document.getElementById("canvas-wrap");
        const maxW = wrap.clientWidth - 10;
        const maxH = wrap.clientHeight - 10;
        // Include VISUAL_MARGIN at top and bottom for charges placed outside field
        const totalW = FIELD_W + GOAL_DEPTH + WALL_T * 2;
        const totalH = FIELD_H + WALL_T * 2 + VISUAL_MARGIN * 2;
        const aspect = totalW / totalH;

        let w, h;
        if (maxW / maxH > aspect) {
          h = maxH;
          w = h * aspect;
        } else {
          w = maxW;
          h = w / aspect;
        }

        const dpr = window.devicePixelRatio || 1;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + "px";
        canvas.style.height = h + "px";

        scale = w / totalW;
        offsetX = WALL_T;
        offsetY = WALL_T + VISUAL_MARGIN; // Shift field down to make room for top margin

        ctx.setTransform(
          dpr * scale,
          0,
          0,
          dpr * scale,
          dpr * scale * offsetX,
          dpr * scale * offsetY,
        );
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  GOAL GEOMETRY
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function goalTop() {
        return (FIELD_H - GOAL_OPENING) / 2;
      }
      function goalBot() {
        return (FIELD_H + GOAL_OPENING) / 2;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  PHYSICS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function computeForceOn(px, py, pCharge, excludeIndex) {
        let fx = 0,
          fy = 0;
        for (let i = 0; i < charges.length; i++) {
          if (i === excludeIndex) continue;
          const c = charges[i];
          let dx = px - c.x;
          let dy = py - c.y;
          let distSq = dx * dx + dy * dy;
          let dist = Math.sqrt(distSq);
          if (dist < MIN_DIST) dist = MIN_DIST;
          distSq = dist * dist;

          const forceMag = (COULOMB_K * pCharge * c.charge) / distSq;
          fx += (forceMag * dx) / dist;
          fy += (forceMag * dy) / dist;
        }
        return { fx, fy };
      }

      function stepPhysics() {
        if (gameState !== "running") return;

        const subDt = DT / SUB_STEPS;

        for (let s = 0; s < SUB_STEPS; s++) {
          // Compute net force on puck
          const { fx, fy } = computeForceOn(puck.x, puck.y, puck.charge, -1);

          // Acceleration (F = ma)
          const ax = fx / puckMass;
          const ay = fy / puckMass;

          // Velocity Verlet: half-step velocity
          puck.vx += ax * subDt * 0.5;
          puck.vy += ay * subDt * 0.5;

          // Clamp speed
          const speed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
          if (speed > MAX_SPEED) {
            puck.vx = (puck.vx / speed) * MAX_SPEED;
            puck.vy = (puck.vy / speed) * MAX_SPEED;
          }

          // Update position
          puck.x += puck.vx * subDt;
          puck.y += puck.vy * subDt;

          // Second half-step velocity (with new position force)
          const f2 = computeForceOn(puck.x, puck.y, puck.charge, -1);
          puck.vx += (f2.fx / puckMass) * subDt * 0.5;
          puck.vy += (f2.fy / puckMass) * subDt * 0.5;

          // Wall collisions (internal)
          for (const wall of walls) {
            resolveCircleRect(puck, wall);
          }

          // Boundary collisions
          handleBoundary();

          // Goal check
          if (checkGoal()) {
            gameState = "won";
            spawnCelebration();
            updateUI();
            return;
          }
        }

        // Record trail
        if (showTrace) {
          trail.push({ x: puck.x, y: puck.y });
          if (trail.length > 2000) trail.shift();
        }
      }

      function resolveCircleRect(circle, rect) {
        // Find closest point on rectangle to circle center
        const closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.w));
        const closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.h));

        const dx = circle.x - closestX;
        const dy = circle.y - closestY;
        const distSq = dx * dx + dy * dy;
        const r = circle.radius;

        if (distSq < r * r && distSq > 0.001) {
          const dist = Math.sqrt(distSq);
          const nx = dx / dist;
          const ny = dy / dist;
          const overlap = r - dist + 0.5; // extra push to prevent sticking

          // Push out
          circle.x += nx * overlap;
          circle.y += ny * overlap;

          // Reflect velocity along collision normal
          const vDotN = circle.vx * nx + circle.vy * ny;
          if (vDotN < 0) {
            circle.vx -= (1 + BOUNCE_COEFF) * vDotN * nx;
            circle.vy -= (1 + BOUNCE_COEFF) * vDotN * ny;
          }
        } else if (distSq <= 0.001) {
          // Circle center is inside the rectangle - push out to nearest edge
          const dLeft = circle.x - rect.x;
          const dRight = rect.x + rect.w - circle.x;
          const dTop = circle.y - rect.y;
          const dBot = rect.y + rect.h - circle.y;
          const minD = Math.min(dLeft, dRight, dTop, dBot);

          if (minD === dLeft) {
            circle.x = rect.x - r - 1;
            circle.vx = -Math.abs(circle.vx) * BOUNCE_COEFF;
          } else if (minD === dRight) {
            circle.x = rect.x + rect.w + r + 1;
            circle.vx = Math.abs(circle.vx) * BOUNCE_COEFF;
          } else if (minD === dTop) {
            circle.y = rect.y - r - 1;
            circle.vy = -Math.abs(circle.vy) * BOUNCE_COEFF;
          } else {
            circle.y = rect.y + rect.h + r + 1;
            circle.vy = Math.abs(circle.vy) * BOUNCE_COEFF;
          }
        }
      }

      function handleBoundary() {
        const r = puck.radius;
        const gt = goalTop();
        const gb = goalBot();

        // --- Out-of-bounds check: reset if puck exits the LARGE physics field (2x visible) ---
        if (
          puck.x < PHYSICS_OFFSET_X ||
          puck.x > PHYSICS_OFFSET_X + PHYSICS_FIELD_W ||
          puck.y < PHYSICS_OFFSET_Y ||
          puck.y > PHYSICS_OFFSET_Y + PHYSICS_FIELD_H
        ) {
          gameState = "setup";
          oobFlashTimer = 90; // ~1.5 seconds of flash
          resetPuck();
          updateUI();
          return;
        }

        // NO bouncing off visible field borders - puck passes through freely
        // Puck ONLY bounces off: obstacles, goal poles, goal back wall

        // --- Goal area collisions (only when puck is near the goal) ---
        if (puck.x > FIELD_W - r - 10) {
          const inGoalY = puck.y > gt + r + 2 && puck.y < gb - r - 2;

          if (inGoalY) {
            // Inside goal corridor â€” constrain to goal walls (top/bottom posts)
            if (puck.y < gt + r) {
              puck.y = gt + r;
              puck.vy = Math.abs(puck.vy) * BOUNCE_COEFF;
            }
            if (puck.y > gb - r) {
              puck.y = gb - r;
              puck.vy = -Math.abs(puck.vy) * BOUNCE_COEFF;
            }
            // Back wall of goal (net)
            if (puck.x > FIELD_W + GOAL_DEPTH - r) {
              puck.x = FIELD_W + GOAL_DEPTH - r;
              puck.vx = -Math.abs(puck.vx) * BOUNCE_COEFF;
            }
          }
        }

        // Goal post collision boxes (top and bottom posts)
        resolveCircleRect(puck, {
          x: FIELD_W - WALL_T / 2,
          y: gt - WALL_T,
          w: GOAL_DEPTH + WALL_T / 2,
          h: WALL_T,
        });
        resolveCircleRect(puck, {
          x: FIELD_W - WALL_T / 2,
          y: gb,
          w: GOAL_DEPTH + WALL_T / 2,
          h: WALL_T,
        });
      }

      function checkGoal() {
        const gt = goalTop();
        const gb = goalBot();
        return (
          puck.x > FIELD_W + GOAL_DEPTH * 0.4 && puck.y > gt && puck.y < gb
        );
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  FIELD VISUALIZATION
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function computeFieldGrid() {
        if (!fieldCacheDirty && fieldCache) return fieldCache;

        const spacing = 40;
        const cols = Math.floor(FIELD_W / spacing);
        const rows = Math.floor(FIELD_H / spacing);
        const grid = [];

        for (let r = 0; r <= rows; r++) {
          for (let c = 0; c <= cols; c++) {
            const x = c * spacing + spacing / 2;
            const y = r * spacing + spacing / 2;
            if (x > FIELD_W || y > FIELD_H) continue;

            let ex = 0,
              ey = 0;
            for (const ch of charges) {
              const dx = x - ch.x;
              const dy = y - ch.y;
              let dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < MIN_DIST) dist = MIN_DIST;
              const eMag = (COULOMB_K * ch.charge) / (dist * dist);
              ex += (eMag * dx) / dist;
              ey += (eMag * dy) / dist;
            }

            const mag = Math.sqrt(ex * ex + ey * ey);
            grid.push({ x, y, ex, ey, mag });
          }
        }

        fieldCache = grid;
        fieldCacheDirty = false;
        return grid;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  CELEBRATION PARTICLES
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function spawnCelebration() {
        const cx = FIELD_W + GOAL_DEPTH / 2;
        const cy = FIELD_H / 2;
        for (let i = 0; i < 120; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 2 + Math.random() * 8;
          particles.push({
            x: cx,
            y: cy,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 2,
            life: 1,
            decay: 0.008 + Math.random() * 0.015,
            hue: Math.random() * 360,
            size: 2 + Math.random() * 6,
          });
        }
      }

      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.08;
          p.life -= p.decay;
          if (p.life <= 0) particles.splice(i, 1);
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  RENDERING
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function render() {
        // Clear everything (including outside field)
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillStyle = COL.bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();

        drawFieldBackground();
        drawGoal();
        if (showField && charges.length > 0) drawFieldVectors();
        if (showTrace && trail.length > 1) drawTrail();
        drawWalls();
        drawCharges();
        drawPuck();
        if (showForce && charges.length > 0) drawForceArrow();
        drawParticles();
        if (gameState === "won") drawWinOverlay();
        if (mouseOnField && canManipulateCharges() && !dragTarget)
          drawGhostCharge();
        if (oobFlashTimer > 0) drawOobFlash();
      }

      function drawOobFlash() {
        const alpha = Math.min(oobFlashTimer / 30, 1) * 0.35;
        ctx.save();
        ctx.fillStyle = `rgba(255, 50, 50, ${alpha})`;
        ctx.fillRect(
          -WALL_T,
          -WALL_T - VISUAL_MARGIN,
          FIELD_W + GOAL_DEPTH + WALL_T * 2,
          FIELD_H + WALL_T * 2 + VISUAL_MARGIN * 2,
        );

        if (oobFlashTimer > 40) {
          ctx.font = "bold 28px Orbitron, monospace";
          ctx.fillStyle = `rgba(255, 100, 100, ${Math.min(oobFlashTimer / 40, 1)})`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(
            TRANSLATIONS[currentLang].outOfBounds,
            FIELD_W / 2,
            FIELD_H / 2,
          );
        }
        ctx.restore();
      }

      function drawFieldBackground() {
        // Field area
        ctx.fillStyle = "#0a1020";
        ctx.fillRect(0, 0, FIELD_W, FIELD_H);

        // Subtle grid
        ctx.strokeStyle = COL.grid;
        ctx.lineWidth = 0.5;
        const spacing = 40;
        for (let x = spacing; x < FIELD_W; x += spacing) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, FIELD_H);
          ctx.stroke();
        }
        for (let y = spacing; y < FIELD_H; y += spacing) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(FIELD_W, y);
          ctx.stroke();
        }

        // Border
        ctx.strokeStyle = COL.wall;
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, FIELD_W, FIELD_H);

        // Starting position indicator (when in setup)
        if (gameState === "setup") {
          ctx.save();
          ctx.globalAlpha = 0.15;
          ctx.beginPath();
          ctx.arc(FIELD_W * 0.12, FIELD_H / 2, 30, 0, Math.PI * 2);
          ctx.fillStyle = COL.puck;
          ctx.fill();
          ctx.restore();
        }
      }

      function drawGoal() {
        const gt = goalTop();
        const gb = goalBot();

        // Goal area fill
        ctx.fillStyle = COL.goalFill;
        ctx.fillRect(FIELD_W, gt, GOAL_DEPTH, GOAL_OPENING);

        // Net pattern
        ctx.strokeStyle = COL.goalNet;
        ctx.lineWidth = 0.5;
        const step = 12;
        for (let x = FIELD_W + step; x < FIELD_W + GOAL_DEPTH; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, gt);
          ctx.lineTo(x, gb);
          ctx.stroke();
        }
        for (let y = gt + step; y < gb; y += step) {
          ctx.beginPath();
          ctx.moveTo(FIELD_W, y);
          ctx.lineTo(FIELD_W + GOAL_DEPTH, y);
          ctx.stroke();
        }

        // Goal frame
        ctx.strokeStyle = COL.goalBorder;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(FIELD_W, gt);
        ctx.lineTo(FIELD_W + GOAL_DEPTH, gt);
        ctx.lineTo(FIELD_W + GOAL_DEPTH, gb);
        ctx.lineTo(FIELD_W, gb);
        ctx.stroke();

        // Goal posts glow
        ctx.save();
        ctx.shadowColor = COL.goalBorder;
        ctx.shadowBlur = 12;
        ctx.fillStyle = COL.goalBorder;
        ctx.beginPath();
        ctx.arc(FIELD_W, gt, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(FIELD_W, gb, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        // Goal label
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.font = "bold 11px Orbitron, monospace";
        ctx.fillStyle = COL.goalBorder;
        ctx.textAlign = "center";
        ctx.fillText(
          TRANSLATIONS[currentLang].goalLabel,
          FIELD_W + GOAL_DEPTH / 2,
          FIELD_H / 2 + 4,
        );
        ctx.restore();
      }

      function drawWalls() {
        for (const w of walls) {
          // Glow
          ctx.save();
          ctx.shadowColor = COL.wallGlow;
          ctx.shadowBlur = 8;
          ctx.fillStyle = COL.wall;
          ctx.fillRect(w.x, w.y, w.w, w.h);
          ctx.restore();

          // Highlight edge
          ctx.strokeStyle = "rgba(200,210,230,0.3)";
          ctx.lineWidth = 1;
          ctx.strokeRect(w.x, w.y, w.w, w.h);
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  ENHANCED: Glowing charges
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function drawCharges() {
        for (let i = 0; i < charges.length; i++) {
          const c = charges[i];
          const isPos = c.charge > 0;
          const color = isPos ? COL.positive : COL.negative;
          const bright = isPos ? COL.posBright : COL.negBright;
          const glow = isPos ? COL.posGlow : COL.negGlow;
          const core = isPos ? COL.posCore : COL.negCore;

          // Animated pulse
          const pulsePhase = ((Date.now() + i * 200) % 1500) / 1500;
          const pulseScale = 1 + Math.sin(pulsePhase * Math.PI * 2) * 0.08;

          ctx.save();

          // Outer glow rings
          ctx.shadowColor = color;
          ctx.shadowBlur = 25;

          // Outermost glow ring
          ctx.globalAlpha = 0.2;
          ctx.beginPath();
          ctx.arc(c.x, c.y, CHARGE_R * 1.8 * pulseScale, 0, Math.PI * 2);
          ctx.strokeStyle = color;
          ctx.lineWidth = 1;
          ctx.stroke();

          // Middle glow ring
          ctx.globalAlpha = 0.3;
          ctx.beginPath();
          ctx.arc(c.x, c.y, CHARGE_R * 1.4 * pulseScale, 0, Math.PI * 2);
          ctx.stroke();

          // Main circle with gradient
          ctx.globalAlpha = 1;
          const chargeGradient = ctx.createRadialGradient(
            c.x - CHARGE_R * 0.3, c.y - CHARGE_R * 0.3, 0,
            c.x, c.y, CHARGE_R * 1.2
          );
          chargeGradient.addColorStop(0, core);
          chargeGradient.addColorStop(0.4, glow);
          chargeGradient.addColorStop(1, "rgba(0,0,0,0)");

          ctx.beginPath();
          ctx.arc(c.x, c.y, CHARGE_R * 1.1, 0, Math.PI * 2);
          ctx.fillStyle = chargeGradient;
          ctx.fill();

          // Main stroke
          ctx.beginPath();
          ctx.arc(c.x, c.y, CHARGE_R, 0, Math.PI * 2);
          ctx.strokeStyle = bright;
          ctx.lineWidth = 2.5;
          ctx.stroke();

          // Inner highlight
          ctx.beginPath();
          ctx.arc(c.x, c.y, CHARGE_R - 3, 0, Math.PI * 2);
          ctx.strokeStyle = color;
          ctx.lineWidth = 1;
          ctx.globalAlpha = 0.4;
          ctx.stroke();

          ctx.restore();

          // Symbol with glow
          ctx.save();
          ctx.shadowColor = bright;
          ctx.shadowBlur = 8;
          ctx.strokeStyle = bright;
          ctx.lineCap = "round";
          ctx.lineWidth = 3;
          const symLen = 7;

          // Horizontal line
          ctx.beginPath();
          ctx.moveTo(c.x - symLen, c.y);
          ctx.lineTo(c.x + symLen, c.y);
          ctx.stroke();

          // Vertical line (+ only)
          if (isPos) {
            ctx.beginPath();
            ctx.moveTo(c.x, c.y - symLen);
            ctx.lineTo(c.x, c.y + symLen);
            ctx.stroke();
          }
          ctx.restore();
        }
      }

      function drawPuck() {
        if (!puck) return;

        // Color based on charge
        const isPositive = puck.charge >= 0;
        const puckColor = isPositive ? COL.puck : "#ff6688";
        const puckFill = isPositive ? "rgba(0,255,136,0.2)" : "rgba(255,102,136,0.2)";

        // Glow
        ctx.save();
        ctx.shadowColor = puckColor;
        ctx.shadowBlur = 20;

        // Main circle
        ctx.beginPath();
        ctx.arc(puck.x, puck.y, PUCK_R, 0, Math.PI * 2);
        ctx.fillStyle = puckFill;
        ctx.fill();
        ctx.strokeStyle = puckColor;
        ctx.lineWidth = 2.5;
        ctx.stroke();
        ctx.restore();

        // Symbol based on charge (+ or -)
        ctx.strokeStyle = puckColor;
        ctx.lineCap = "round";
        ctx.lineWidth = 2.5;
        const puckSymLen = 6;
        // Horizontal line (both + and -)
        ctx.beginPath();
        ctx.moveTo(puck.x - puckSymLen, puck.y);
        ctx.lineTo(puck.x + puckSymLen, puck.y);
        ctx.stroke();
        // Vertical line (only for positive)
        if (isPositive) {
          ctx.beginPath();
          ctx.moveTo(puck.x, puck.y - puckSymLen);
          ctx.lineTo(puck.x, puck.y + puckSymLen);
          ctx.stroke();
        }
      }

      function drawTrail() {
        if (trail.length < 2) return;
        for (let i = 1; i < trail.length; i++) {
          const alpha = (i / trail.length) * 0.6;
          ctx.strokeStyle = COL.trail + alpha.toFixed(3) + ")";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(trail[i - 1].x, trail[i - 1].y);
          ctx.lineTo(trail[i].x, trail[i].y);
          ctx.stroke();
        }
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  ENHANCED: Field vectors with gradient colors
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function drawFieldVectors() {
        const grid = computeFieldGrid();
        if (!grid.length) return;

        const maxMag = Math.max(...grid.map((g) => g.mag), 1);
        const arrowLen = 42; // 1.5x longer (was 28)

        for (const pt of grid) {
          if (pt.mag < 0.01) continue;

          const strength = Math.min(pt.mag / maxMag, 1);
          const len = arrowLen * Math.pow(strength, 0.35);
          const angle = Math.atan2(pt.ey, pt.ex);

          const endX = pt.x + Math.cos(angle) * len;
          const endY = pt.y + Math.sin(angle) * len;

          // Color gradient based on strength
          const hue = 180 + strength * 20; // Cyan to slightly more blue
          const lightness = 50 + strength * 20;
          const alpha = 0.25 + strength * 0.5;

          ctx.save();

          // Glow for strong fields
          if (strength > 0.5) {
            ctx.shadowColor = `hsla(${hue}, 100%, ${lightness}%, 0.4)`;
            ctx.shadowBlur = 4;
          }

          // Arrow shaft gradient
          const arrowGradient = ctx.createLinearGradient(pt.x, pt.y, endX, endY);
          arrowGradient.addColorStop(0, `hsla(${hue}, 80%, ${lightness}%, ${alpha * 0.3})`);
          arrowGradient.addColorStop(1, `hsla(${hue}, 100%, ${lightness}%, ${alpha})`);

          ctx.strokeStyle = arrowGradient;
          ctx.lineWidth = 0.8 + strength * 0.8;
          ctx.lineCap = "round";

          // Line
          ctx.beginPath();
          ctx.moveTo(pt.x, pt.y);
          ctx.lineTo(endX, endY);
          ctx.stroke();

          // Arrowhead (filled triangle for better visibility)
          const headLen = 4 + strength * 3;
          const headAngle = 0.5;
          ctx.fillStyle = `hsla(${hue}, 100%, ${lightness}%, ${alpha})`;
          ctx.beginPath();
          ctx.moveTo(endX, endY);
          ctx.lineTo(
            endX - Math.cos(angle - headAngle) * headLen,
            endY - Math.sin(angle - headAngle) * headLen,
          );
          ctx.lineTo(
            endX - Math.cos(angle + headAngle) * headLen,
            endY - Math.sin(angle + headAngle) * headLen,
          );
          ctx.closePath();
          ctx.fill();

          ctx.restore();
        }
      }

      function drawForceArrow() {
        if (!puck) return;
        const { fx, fy } = computeForceOn(puck.x, puck.y, puck.charge, -1);
        const mag = Math.sqrt(fx * fx + fy * fy);
        if (mag < 0.1) return;

        // Scale arrow length - 5x longer, max 400px
        const maxArrowLen = 400;
        const arrowLen = Math.min(mag * 0.1, maxArrowLen);
        const angle = Math.atan2(fy, fx);

        // Scale line width with arrow length (2 to 6 pixels)
        const lineWidth = 2 + (arrowLen / maxArrowLen) * 4;

        const endX = puck.x + Math.cos(angle) * arrowLen;
        const endY = puck.y + Math.sin(angle) * arrowLen;

        ctx.save();
        ctx.strokeStyle = COL.forceArrow;
        ctx.fillStyle = COL.forceArrow;
        ctx.lineWidth = lineWidth;
        ctx.lineCap = "round";
        ctx.shadowColor = COL.forceArrow;
        ctx.shadowBlur = 6 + lineWidth;

        // Shaft
        ctx.beginPath();
        ctx.moveTo(puck.x, puck.y);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        // Arrowhead - scales with line width
        const headLen = 8 + lineWidth * 2;
        const headAngle = 0.4;
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(
          endX - Math.cos(angle - headAngle) * headLen,
          endY - Math.sin(angle - headAngle) * headLen,
        );
        ctx.lineTo(
          endX - Math.cos(angle + headAngle) * headLen,
          endY - Math.sin(angle + headAngle) * headLen,
        );
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      }

      function drawParticles() {
        for (const p of particles) {
          ctx.save();
          ctx.globalAlpha = p.life;
          ctx.fillStyle = `hsl(${p.hue}, 100%, 65%)`;
          ctx.shadowColor = `hsl(${p.hue}, 100%, 65%)`;
          ctx.shadowBlur = 6;
          ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
          ctx.restore();
        }
      }

      function drawWinOverlay() {
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = "#000";
        ctx.fillRect(
          -WALL_T,
          -WALL_T - VISUAL_MARGIN,
          FIELD_W + GOAL_DEPTH + WALL_T * 2,
          FIELD_H + WALL_T * 2 + VISUAL_MARGIN * 2,
        );
        ctx.restore();

        ctx.save();
        ctx.shadowColor = COL.goalBorder;
        ctx.shadowBlur = 40;
        ctx.font = "bold 96px Orbitron, monospace";
        ctx.fillStyle = COL.goalBorder;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(
          TRANSLATIONS[currentLang].goalText,
          FIELD_W / 2,
          FIELD_H / 2 - 30,
        );

        ctx.restore();
      }

      function drawGhostCharge() {
        if (mouseField.x < -CHARGE_MARGIN || mouseField.y < -CHARGE_MARGIN) return;
        if (mouseField.x > FIELD_W + CHARGE_MARGIN || mouseField.y > FIELD_H + CHARGE_MARGIN) return;

        const isPos = selectedCharge > 0;
        const color = isPos ? COL.positive : COL.negative;

        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(mouseField.x, mouseField.y, CHARGE_R, 0, Math.PI * 2);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // Symbol (drawn with lines)
        ctx.strokeStyle = color;
        ctx.lineCap = "round";
        ctx.lineWidth = 3;
        const ghostSymLen = 8;
        ctx.beginPath();
        ctx.moveTo(mouseField.x - ghostSymLen, mouseField.y);
        ctx.lineTo(mouseField.x + ghostSymLen, mouseField.y);
        ctx.stroke();
        if (isPos) {
          ctx.beginPath();
          ctx.moveTo(mouseField.x, mouseField.y - ghostSymLen);
          ctx.lineTo(mouseField.x, mouseField.y + ghostSymLen);
          ctx.stroke();
        }
        ctx.restore();
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  INPUT HANDLING
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function canvasToField(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const x = (clientX - rect.left) / scale - offsetX;
        const y = (clientY - rect.top) / scale - offsetY;
        return { x, y };
      }

      function findChargeAt(fx, fy) {
        for (let i = charges.length - 1; i >= 0; i--) {
          const c = charges[i];
          const dx = fx - c.x;
          const dy = fy - c.y;
          if (dx * dx + dy * dy < (CHARGE_R + 8) * (CHARGE_R + 8)) return i;
        }
        return -1;
      }

      function isInsideWall(x, y) {
        for (const w of walls) {
          if (
            x > w.x - CHARGE_R &&
            x < w.x + w.w + CHARGE_R &&
            y > w.y - CHARGE_R &&
            y < w.y + w.h + CHARGE_R
          )
            return true;
        }
        return false;
      }

      function isNearPuck(x, y) {
        if (!puck) return false;
        const dx = x - puck.x;
        const dy = y - puck.y;
        return (
          dx * dx + dy * dy < (PUCK_R + CHARGE_R + 5) * (PUCK_R + CHARGE_R + 5)
        );
      }

      // Check if charge manipulation is allowed (blocked in hard mode while running)
      function canManipulateCharges() {
        return !hardMode || gameState === "setup" || gameState === "won";
      }

      // Mouse events
      canvas.addEventListener("mousedown", (e) => {
        e.preventDefault();
        const { x, y } = canvasToField(e.clientX, e.clientY);

        if (e.button === 2) {
          // Right-click: remove charge
          if (!canManipulateCharges()) return;
          const idx = findChargeAt(x, y);
          if (idx >= 0) {
            charges.splice(idx, 1);
            fieldCacheDirty = true;
            updateChargeCount();
          }
          return;
        }

        // Left-click: drag or place
        if (!canManipulateCharges()) return;
        const idx = findChargeAt(x, y);
        if (idx >= 0) {
          dragTarget = {
            type: "charge",
            index: idx,
            ox: charges[idx].x - x,
            oy: charges[idx].y - y,
          };
        } else if (x > -CHARGE_MARGIN && x < FIELD_W + CHARGE_MARGIN &&
                   y > -CHARGE_MARGIN && y < FIELD_H + CHARGE_MARGIN) {
          // Place new charge if not on a wall or puck (extended area around field)
          if (!isInsideWall(x, y) && !isNearPuck(x, y)) {
            charges.push({ x, y, charge: selectedCharge });
            fieldCacheDirty = true;
            updateChargeCount();
            // Start dragging the new charge immediately
            dragTarget = {
              type: "charge",
              index: charges.length - 1,
              ox: 0,
              oy: 0,
            };
          }
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        const { x, y } = canvasToField(e.clientX, e.clientY);
        mouseField.x = x;
        mouseField.y = y;
        // Extended area for charge placement
        mouseOnField = x >= -CHARGE_MARGIN && x <= FIELD_W + CHARGE_MARGIN &&
                       y >= -CHARGE_MARGIN && y <= FIELD_H + CHARGE_MARGIN;

        if (dragTarget) {
          const c = charges[dragTarget.index];
          if (c) {
            c.x = x + dragTarget.ox;
            c.y = y + dragTarget.oy;
            // Clamp to extended charge placement area
            c.x = Math.max(-CHARGE_MARGIN + CHARGE_R, Math.min(FIELD_W + CHARGE_MARGIN - CHARGE_R, c.x));
            c.y = Math.max(-CHARGE_MARGIN + CHARGE_R, Math.min(FIELD_H + CHARGE_MARGIN - CHARGE_R, c.y));
            fieldCacheDirty = true;
          }
        }
      });

      canvas.addEventListener("mouseup", () => {
        dragTarget = null;
      });

      canvas.addEventListener("mouseleave", () => {
        mouseOnField = false;
        dragTarget = null;
      });

      canvas.addEventListener("contextmenu", (e) => e.preventDefault());

      // Touch events
      canvas.addEventListener(
        "touchstart",
        (e) => {
          e.preventDefault();
          if (!canManipulateCharges()) return;
          const touch = e.touches[0];
          const { x, y } = canvasToField(touch.clientX, touch.clientY);

          const idx = findChargeAt(x, y);
          if (idx >= 0) {
            dragTarget = {
              type: "charge",
              index: idx,
              ox: charges[idx].x - x,
              oy: charges[idx].y - y,
            };
          } else if (x > -CHARGE_MARGIN && x < FIELD_W + CHARGE_MARGIN &&
                     y > -CHARGE_MARGIN && y < FIELD_H + CHARGE_MARGIN) {
            if (!isInsideWall(x, y) && !isNearPuck(x, y)) {
              charges.push({ x, y, charge: selectedCharge });
              fieldCacheDirty = true;
              updateChargeCount();
              dragTarget = {
                type: "charge",
                index: charges.length - 1,
                ox: 0,
                oy: 0,
              };
            }
          }
        },
        { passive: false },
      );

      canvas.addEventListener(
        "touchmove",
        (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          const { x, y } = canvasToField(touch.clientX, touch.clientY);
          mouseField.x = x;
          mouseField.y = y;
          mouseOnField = true;

          if (dragTarget) {
            const c = charges[dragTarget.index];
            if (c) {
              c.x = x + dragTarget.ox;
              c.y = y + dragTarget.oy;
              // Clamp to extended charge placement area
              c.x = Math.max(-CHARGE_MARGIN + CHARGE_R, Math.min(FIELD_W + CHARGE_MARGIN - CHARGE_R, c.x));
              c.y = Math.max(-CHARGE_MARGIN + CHARGE_R, Math.min(FIELD_H + CHARGE_MARGIN - CHARGE_R, c.y));
              fieldCacheDirty = true;
            }
          }
        },
        { passive: false },
      );

      canvas.addEventListener("touchend", () => {
        dragTarget = null;
        mouseOnField = false;
      });

      // Long press to remove (mobile)
      let longPressTimer = null;
      canvas.addEventListener(
        "touchstart",
        (e) => {
          if (!canManipulateCharges()) return;
          const touch = e.touches[0];
          const { x, y } = canvasToField(touch.clientX, touch.clientY);
          const idx = findChargeAt(x, y);
          if (idx >= 0) {
            longPressTimer = setTimeout(() => {
              if (!canManipulateCharges()) return;
              charges.splice(idx, 1);
              fieldCacheDirty = true;
              updateChargeCount();
              dragTarget = null;
            }, 500);
          }
        },
        { passive: true },
      );
      canvas.addEventListener("touchend", () => {
        clearTimeout(longPressTimer);
      });
      canvas.addEventListener(
        "touchmove",
        () => {
          clearTimeout(longPressTimer);
        },
        { passive: true },
      );

      // Keyboard shortcuts
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          toggleStartPause();
        } else if (e.code === "KeyR") {
          doReset();
        } else if (e.code === "KeyC") {
          doClear();
        } else if (e.code === "KeyF") {
          showField = !showField;
          document.getElementById("chkField").checked = showField;
          fieldCacheDirty = true;
        } else if (e.code === "KeyT") {
          showTrace = !showTrace;
          document.getElementById("chkTrace").checked = showTrace;
        }
      });

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  UI CONTROLS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function updateUI() {
        const badge = document.getElementById("statusBadge");
        const btn = document.getElementById("btnStart");
        const mBtn = document.getElementById("mStart");
        const t = TRANSLATIONS[currentLang];

        switch (gameState) {
          case "setup":
            badge.textContent = t.setup;
            badge.className = "status";
            btn.textContent = t.start;
            btn.classList.remove("active");
            mBtn.textContent = "â–¶";
            mBtn.classList.remove("active");
            break;
          case "running":
            badge.textContent = t.running;
            badge.className = "status running";
            btn.textContent = t.pause;
            mBtn.textContent = "â¸";
            break;
          case "paused":
            badge.textContent = t.paused;
            badge.className = "status";
            btn.textContent = t.resume;
            mBtn.textContent = "â–¶";
            break;
          case "won":
            badge.textContent = t.goalStatus;
            badge.className = "status won";
            btn.textContent = t.start;
            mBtn.textContent = "â–¶";
            break;
        }
      }

      function updateChargeCount() {
        document.getElementById("chargeCount").textContent = charges.length;
        document.getElementById("mChargeCount").textContent = charges.length;
        document.getElementById("mChargeCountBtn").textContent = charges.length;
      }

      function updatePuckValueDisplay() {
        const mass = parseInt(document.getElementById("massSlider").value);
        const charge = parseInt(document.getElementById("chargeSlider").value);
        const chargeStr = charge > 0 ? "+" + charge : String(charge);
        document.getElementById("mPuckValueBtn").textContent = mass + "/" + chargeStr;
      }

      function toggleStartPause() {
        if (gameState === "setup" || gameState === "won") {
          if (gameState === "won") {
            resetPuck();
            particles = [];
          }
          gameState = "running";
        } else if (gameState === "running") {
          gameState = "paused";
        } else if (gameState === "paused") {
          gameState = "running";
        }
        updateUI();
      }

      function doReset() {
        resetPuck();
        gameState = "setup";
        particles = [];
        updateUI();
      }

      function doClear() {
        charges = [];
        fieldCacheDirty = true;
        updateChargeCount();
        doReset();
      }

      // Sync function for sliders
      function syncSliders(desktopId, mobileId, valId, mValId, onUpdate) {
        const desktop = document.getElementById(desktopId);
        const mobile = document.getElementById(mobileId);
        const desktopVal = document.getElementById(valId);
        const mobileVal = document.getElementById(mValId);

        function update(value) {
          desktop.value = value;
          mobile.value = value;
          const displayVal = onUpdate(parseInt(value));
          desktopVal.textContent = displayVal;
          mobileVal.textContent = displayVal;
          updatePuckValueDisplay();
        }

        desktop.addEventListener("input", (e) => update(e.target.value));
        mobile.addEventListener("input", (e) => update(e.target.value));
      }

      // Sync function for display toggles (desktop checkbox + mobile button + mobile label)
      function setupDisplayToggle(checkboxId, mobileBtn, mobileLabel, stateGetter, stateSetter) {
        const checkbox = document.getElementById(checkboxId);
        const btn = document.getElementById(mobileBtn);
        const label = document.getElementById(mobileLabel);

        function updateUI(checked) {
          checkbox.checked = checked;
          btn.classList.toggle("active", checked);
          if (label) label.classList.toggle("active", checked);
          stateSetter(checked);
        }

        checkbox.addEventListener("change", (e) => updateUI(e.target.checked));
        btn.addEventListener("click", () => updateUI(!stateGetter()));
        if (label) {
          label.addEventListener("click", () => updateUI(!stateGetter()));
        }
      }

      // Level buttons (desktop)
      document.getElementById("levelBtns").addEventListener("click", (e) => {
        const btn = e.target.closest("button");
        if (!btn) return;
        selectLevel(btn.dataset.level);
      });

      // Level buttons (mobile)
      ["mLevelP", "mLevel1", "mLevel2", "mLevel3"].forEach(id => {
        document.getElementById(id).addEventListener("click", () => {
          const level = id === "mLevelP" ? "practice" : id.slice(-1);
          selectLevel(level);
        });
      });

      function selectLevel(level) {
        // Update desktop buttons - toggle active class and text
        document.querySelectorAll("#levelBtns button").forEach((b) => b.classList.remove("active"));
        document.querySelector(`#levelBtns button[data-level="${level}"]`).classList.add("active");
        updateDesktopLevelText(level);
        // Update mobile buttons - toggle active class only
        document.getElementById("mLevelP").classList.toggle("active", level === "practice");
        document.getElementById("mLevel1").classList.toggle("active", level === "1");
        document.getElementById("mLevel2").classList.toggle("active", level === "2");
        document.getElementById("mLevel3").classList.toggle("active", level === "3");
        charges = [];
        updateChargeCount();
        initLevel(level);
      }

      function updateDesktopLevelText(selectedLevel) {
        const t = TRANSLATIONS[currentLang];
        const btns = document.querySelectorAll("#levelBtns button");
        btns.forEach(btn => {
          const lvl = btn.dataset.level;
          if (lvl === "practice") {
            btn.textContent = selectedLevel === "practice" ? t.practice : t.practiceShort;
          } else if (lvl === "1") {
            btn.textContent = selectedLevel === "1" ? t.level1 : t.level1Short;
          } else if (lvl === "2") {
            btn.textContent = selectedLevel === "2" ? t.level2 : t.level2Short;
          } else if (lvl === "3") {
            btn.textContent = selectedLevel === "3" ? t.level3 : t.level3Short;
          }
        });
      }

      // Mode buttons (desktop)
      document.getElementById("modeBtns").addEventListener("click", (e) => {
        const btn = e.target.closest("button");
        if (!btn) return;
        selectMode(btn.dataset.mode);
      });

      // Mode buttons (mobile)
      document.getElementById("mModeEasy").addEventListener("click", () => selectMode("easy"));
      document.getElementById("mModeHard").addEventListener("click", () => selectMode("hard"));

      function selectMode(mode) {
        hardMode = mode === "hard";
        // Desktop
        document.querySelectorAll("#modeBtns button").forEach((b) => b.classList.remove("active"));
        document.querySelector(`#modeBtns button[data-mode="${mode}"]`).classList.add("active");
        // Mobile
        document.getElementById("mModeEasy").classList.toggle("active", mode === "easy");
        document.getElementById("mModeHard").classList.toggle("active", mode === "hard");
        // Drawer label
        const modeLabel = document.getElementById("mModeLabel");
        modeLabel.textContent = mode === "easy" ? "Viegls" : "GrÅ«ts";
      }

      // Charge type buttons (desktop)
      document.getElementById("chargeBtns").addEventListener("click", (e) => {
        const btn = e.target.closest("button");
        if (!btn) return;
        selectChargeType(parseFloat(btn.dataset.charge));
      });

      // Charge type buttons (mobile)
      document.getElementById("mChargePos").addEventListener("click", () => selectChargeType(1));
      document.getElementById("mChargeNeg").addEventListener("click", () => selectChargeType(-1));

      function selectChargeType(val) {
        selectedCharge = val;
        // Desktop
        document.querySelectorAll("#chargeBtns button").forEach((b) => {
          b.classList.remove("active-pos", "active-neg");
        });
        document.querySelector(`#chargeBtns button[data-charge="${val > 0 ? '+1' : '-1'}"]`)
          .classList.add(val > 0 ? "active-pos" : "active-neg");
        // Mobile - glowing orb buttons
        const posBtn = document.getElementById("mChargePos");
        const negBtn = document.getElementById("mChargeNeg");
        posBtn.classList.toggle("active-pos", val > 0);
        negBtn.classList.toggle("active-neg", val < 0);
      }

      // Start/Pause buttons
      document.getElementById("btnStart").addEventListener("click", toggleStartPause);
      document.getElementById("mStart").addEventListener("click", toggleStartPause);

      // Reset buttons
      document.getElementById("btnReset").addEventListener("click", doReset);
      document.getElementById("mReset").addEventListener("click", doReset);

      // Clear buttons
      document.getElementById("btnClear").addEventListener("click", doClear);
      document.getElementById("mClear").addEventListener("click", doClear);

      // Mass slider sync
      syncSliders("massSlider", "mMassSlider", "massVal", "mMassVal", (val) => {
        puckMass = val;
        return val;
      });

      // Charge slider sync
      syncSliders("chargeSlider", "mChargeSlider", "chargeVal", "mChargeVal", (val) => {
        puckCharge = val;
        if (puck) puck.charge = puckCharge;
        return val > 0 ? "+" + val : val;
      });

      // Display checkboxes sync
      setupDisplayToggle("chkField", "mField", "mLabelField", () => showField, (v) => {
        showField = v;
        fieldCacheDirty = true;
      });
      setupDisplayToggle("chkTrace", "mTrace", "mLabelTrace", () => showTrace, (v) => {
        showTrace = v;
        if (!showTrace) trail = [];
      });
      setupDisplayToggle("chkForce", "mForce", "mLabelForce", () => showForce, (v) => {
        showForce = v;
      });

      // Mobile drawer toggle - multiple triggers
      const mobileDrawer = document.getElementById("mobileDrawer");

      function toggleDrawer() {
        mobileDrawer.classList.toggle("open");
        const toggle = document.getElementById("drawerToggle");
        toggle.textContent = mobileDrawer.classList.contains("open") ? "â–²" : "â–¼";
      }

      function openDrawer() {
        mobileDrawer.classList.add("open");
        document.getElementById("drawerToggle").textContent = "â–²";
      }

      document.getElementById("drawerToggle").addEventListener("click", toggleDrawer);
      document.getElementById("mChargeCountBtn").addEventListener("click", openDrawer);
      document.getElementById("mPuckValueBtn").addEventListener("click", openDrawer);
      document.getElementById("drawerCharges").addEventListener("click", openDrawer);
      document.getElementById("drawerPuck").addEventListener("click", openDrawer);

      // Close drawer when clicking on canvas
      canvas.addEventListener("click", () => {
        if (mobileDrawer.classList.contains("open")) {
          mobileDrawer.classList.remove("open");
          document.getElementById("drawerToggle").textContent = "â–¼";
        }
      }, true);

      // Mobile language switch
      document.querySelectorAll(".mobile-lang-switch button").forEach((btn) => {
        btn.addEventListener("click", () => setLanguage(btn.dataset.lang));
      });

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  GAME LOOP
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      function gameLoop() {
        stepPhysics();
        updateParticles();
        if (oobFlashTimer > 0) oobFlashTimer--;
        render();
        requestAnimationFrame(gameLoop);
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      //  START
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      initLanguage();
      initLevel("practice");
      gameLoop();
    </script>
  </body>
</html>

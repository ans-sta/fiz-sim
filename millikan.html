<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Millikan Oil Drop Experiment</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      background: #1a1a2e;
      height: 100vh;
      height: 100dvh;
      font-family: 'Courier New', monospace;
      color: #ccc;
      overflow: hidden;
    }

    /* ========== HAMBURGER BUTTON ========== */
    .hamburger-btn {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 100;
      width: 44px;
      height: 44px;
      background: linear-gradient(145deg, #3a3a4a, #252535);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 5px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.4);
    }

    .hamburger-btn span {
      display: block;
      width: 22px;
      height: 2px;
      background: #daa520;
      border-radius: 1px;
      transition: all 0.3s;
    }

    .hamburger-btn:active {
      transform: scale(0.95);
    }

    /* ========== LANGUAGE SWITCH ========== */
    .lang-switch {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 100;
      font-family: 'Courier New', monospace;
      font-size: 13px;
    }

    .lang-switch button {
      background: none;
      border: none;
      color: #555;
      cursor: pointer;
      padding: 4px 8px;
      transition: color 0.2s;
      font-family: inherit;
      font-size: inherit;
    }

    .lang-switch button:hover { color: #888; }
    .lang-switch button.active { color: #daa520; }
    .lang-switch .lang-sep { color: #444; }

    /* ========== DRAWER OVERLAY ========== */
    .drawer-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
    }

    .drawer-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    /* ========== SIDE DRAWER (centered modal) ========== */
    .drawer {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0.9);
      width: 75vw;
      max-width: 500px;
      max-height: 85vh;
      background: #1a1a2e;
      border: 2px solid #3a3a4a;
      border-radius: 16px;
      z-index: 300;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s, transform 0.3s;
      padding: 24px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .drawer.open {
      opacity: 1;
      visibility: visible;
      transform: translate(-50%, -50%) scale(1);
    }

    .drawer-close {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 32px;
      height: 32px;
      background: none;
      border: 1px solid #3a3a4a;
      border-radius: 50%;
      color: #888;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .drawer-close:hover {
      color: #daa520;
      border-color: #daa520;
    }

    .drawer-title {
      font-size: 1rem;
      color: #daa520;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-top: 20px;
      line-height: 1.4;
      text-align: center;
    }

    .drawer-description {
      font-size: 0.85rem;
      color: #888;
      line-height: 1.5;
      text-align: center;
    }

    .drawer-knobs {
      display: flex;
      justify-content: space-around;
      gap: 15px;
      margin-top: 10px;
    }

    /* ========== KNOBS (in drawer) ========== */
    .knob-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .knob-label {
      font-size: 0.65rem;
      color: #888;
      text-transform: uppercase;
      letter-spacing: 1px;
      text-align: center;
    }

    .knob-wrapper {
      position: relative;
    }

    .knob {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: linear-gradient(145deg, #4a4a5a, #2a2a3a);
      box-shadow:
        0 4px 8px rgba(0,0,0,0.4),
        inset 0 2px 4px rgba(255,255,255,0.1);
      cursor: pointer;
      position: relative;
      transition: transform 0.1s;
    }

    .knob:active {
      transform: scale(0.98);
    }

    .knob::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 3px;
      height: 16px;
      background: linear-gradient(to bottom, #daa520, #b8860b);
      border-radius: 2px;
    }

    .knob-readout {
      background: #0a0a0f;
      border: 2px solid #3a3a4a;
      border-radius: 4px;
      padding: 4px 10px;
      font-size: 0.8rem;
      color: #daa520;
      min-width: 70px;
      text-align: center;
      font-family: 'Courier New', monospace;
    }

    /* ========== MAIN CONTENT ========== */
    .main-content {
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 15px;
      padding: 50px 10px 10px;
    }

    /* ========== MICROSCOPE ========== */
    .microscope-container {
      position: relative;
      /* Size = min of (90vw, 450px, available height) */
      --available-height: calc(100dvh - 200px);
      width: min(90vw, 450px, var(--available-height));
      height: min(90vw, 450px, var(--available-height));
      flex-shrink: 0;
    }

    .microscope-frame {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: linear-gradient(145deg, #3a3a4a, #252535);
      box-shadow:
        0 0 0 6px #2a2a3a,
        0 0 0 10px #3a3a4a,
        inset 0 0 30px rgba(0,0,0,0.5);
    }

    #microscope {
      position: absolute;
      inset: 12px;
      border-radius: 50%;
    }

    /* Ionization flash effect */
    .microscope-container.ionize-flash .microscope-frame {
      box-shadow:
        0 0 0 6px #2a2a3a,
        0 0 0 10px #3a3a4a,
        inset 0 0 30px rgba(0,0,0,0.5),
        inset 0 0 60px rgba(100, 200, 255, 0.3);
    }

    /* ========== BOTTOM CONTROLS ========== */
    .bottom-controls {
      width: 100%;
      max-width: 450px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 10px 0;
    }

    .button-row {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 16px;
    }

    /* Spray & Ionize buttons - golden ratio (56px × 1.618) */
    .spray-btn,
    .ionize-btn {
      background: linear-gradient(145deg, #4a4a5a, #2a2a3a);
      border: none;
      border-radius: 12px;
      width: 90px;
      height: 56px;
      color: #daa520;
      cursor: pointer;
      box-shadow:
        0 4px 8px rgba(0,0,0,0.4),
        inset 0 2px 4px rgba(255,255,255,0.1);
      transition: all 0.1s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .spray-btn:active,
    .ionize-btn:active {
      transform: scale(0.94) translateY(2px);
      box-shadow:
        0 2px 4px rgba(0,0,0,0.4),
        inset 0 2px 4px rgba(255,255,255,0.1);
    }

    .spray-btn svg,
    .ionize-btn svg {
      width: 28px;
      height: 28px;
    }

    /* ========== NIXIE DISPLAY ========== */
    .nixie-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .nixie-tubes {
      display: flex;
      gap: 3px;
      background: #0a0a0f;
      padding: 8px 10px;
      border-radius: 6px;
      border: 2px solid #3a3a4a;
    }

    .nixie-tube {
      width: 28px;
      height: 42px;
      background: radial-gradient(ellipse at center, #1a1008 0%, #0a0a0f 70%);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      box-shadow: inset 0 0 8px rgba(0,0,0,0.8);
    }

    .nixie-tube::before {
      content: '';
      position: absolute;
      inset: 2px;
      border-radius: 4px;
      background: linear-gradient(to bottom,
        rgba(255,140,0,0.05) 0%,
        transparent 30%,
        transparent 70%,
        rgba(255,140,0,0.03) 100%);
      pointer-events: none;
    }

    .nixie-digit {
      font-family: 'Courier New', monospace;
      font-size: 1.5rem;
      font-weight: bold;
      color: #ff8c00;
      text-shadow:
        0 0 8px #ff6600,
        0 0 16px #ff4400,
        0 0 24px #ff2200;
      position: relative;
    }

    .nixie-label {
      font-size: 0.85rem;
      color: #bbb;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    /* ========== VOLTAGE SLIDERS ========== */
    .voltage-sliders {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
      align-items: center;
    }

    .slider-edge-label {
      font-size: 0.85rem;
      color: #bbb;
      font-weight: bold;
      font-family: 'Courier New', monospace;
      min-width: 40px;
      text-align: center;
    }

    /* Fine slider - subtle, spring-return */
    .fine-slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      justify-content: center;
    }

    .fine-slider-track {
      flex: 1;
      max-width: 280px;
      height: 20px;
      background: linear-gradient(to bottom, #1a1a2e, #2a2a3e, #1a1a2e);
      border-radius: 10px;
      border: 1px solid #3a3a4a;
      position: relative;
      cursor: pointer;
    }

    .fine-slider-track::before {
      content: '';
      position: absolute;
      left: 50%;
      top: 4px;
      bottom: 4px;
      width: 1px;
      background: #4a4a5a;
    }

    .fine-slider-thumb {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 24px;
      height: 24px;
      background: linear-gradient(145deg, #5a5a6a, #3a3a4a);
      border-radius: 50%;
      border: 2px solid #888;
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      cursor: grab;
      transition: left 0.15s ease-out;
    }

    .fine-slider-thumb:active {
      cursor: grabbing;
    }

    .fine-slider-thumb.dragging {
      transition: none;
    }

    /* Coarse slider - iPhone unlock style (CHUNKY) */
    .coarse-slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      justify-content: center;
    }

    .coarse-slider {
      flex: 1;
      max-width: 280px;
      height: 50px;
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      cursor: pointer;
    }

    .coarse-slider::-webkit-slider-runnable-track {
      height: 44px;
      background: linear-gradient(to bottom, #0a0a15, #1a1a2e, #0a0a15);
      border-radius: 22px;
      border: 3px solid #3a3a4a;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
    }

    .coarse-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 44px;
      height: 44px;
      background: linear-gradient(145deg, #6a6a7a, #4a4a5a);
      border-radius: 50%;
      margin-top: -3px;
      box-shadow:
        0 4px 12px rgba(0,0,0,0.5),
        inset 0 2px 4px rgba(255,255,255,0.2);
      border: 3px solid #daa520;
    }

    .coarse-slider::-moz-range-track {
      height: 44px;
      background: linear-gradient(to bottom, #0a0a15, #1a1a2e, #0a0a15);
      border-radius: 22px;
      border: 3px solid #3a3a4a;
      box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
    }

    .coarse-slider::-moz-range-thumb {
      width: 44px;
      height: 44px;
      background: linear-gradient(145deg, #6a6a7a, #4a4a5a);
      border-radius: 50%;
      box-shadow:
        0 4px 12px rgba(0,0,0,0.5),
        inset 0 2px 4px rgba(255,255,255,0.2);
      border: 3px solid #daa520;
    }

    /* ========== RESPONSIVE ========== */
    @media (min-height: 700px) {
      .main-content {
        padding-top: 70px;
      }

      .microscope-container {
        --available-height: calc(100dvh - 240px);
        width: min(90vw, 450px, var(--available-height));
        height: min(90vw, 450px, var(--available-height));
      }

      .bottom-controls {
        gap: 12px;
      }
    }

    @media (min-width: 500px) {
      .bottom-controls {
        max-width: 400px;
      }
    }
  </style>
</head>
<body>
  <!-- Hamburger menu button -->
  <button class="hamburger-btn" id="hamburger-btn" aria-label="Open menu">
    <span></span>
    <span></span>
    <span></span>
  </button>

  <!-- Language switch -->
  <div class="lang-switch">
    <button data-lang="lv">LV</button>
    <span class="lang-sep">|</span>
    <button data-lang="en">EN</button>
  </div>

  <!-- Drawer overlay -->
  <div class="drawer-overlay" id="drawer-overlay"></div>

  <!-- Side drawer -->
  <div class="drawer" id="drawer">
    <button class="drawer-close" id="drawer-close" aria-label="Close menu">✕</button>
    <h1 class="drawer-title" data-i18n="title">Millikan Oil Drop Experiment</h1>
    <p class="drawer-description" data-i18n="description">Measure the elementary electric charge by balancing oil droplets in an electric field.</p>

    <div class="drawer-knobs">
      <div class="knob-container">
        <span class="knob-label" data-i18n="plateGap">Plate Gap, mm</span>
        <div class="knob-wrapper">
          <div class="knob" id="knob-d"></div>
        </div>
        <div class="knob-readout" id="readout-d">6</div>
      </div>

      <div class="knob-container">
        <span class="knob-label" data-i18n="oilMass">Oil Mass, ×10⁻¹⁵ kg</span>
        <div class="knob-wrapper">
          <div class="knob" id="knob-m"></div>
        </div>
        <div class="knob-readout" id="readout-m">5.0</div>
      </div>
    </div>
  </div>

  <!-- Main content -->
  <main class="main-content">
    <div class="microscope-container">
      <div class="microscope-frame"></div>
      <canvas id="microscope"></canvas>
    </div>

    <div class="bottom-controls">
      <div class="button-row">
        <button class="spray-btn" id="spray-btn" data-i18n-title="sprayOil" title="Spray Oil">
          <!-- Cloud of dots icon -->
          <svg viewBox="0 0 32 32" width="28" height="28">
            <circle cx="8" cy="20" r="2" fill="currentColor" opacity="0.6"/>
            <circle cx="14" cy="22" r="1.5" fill="currentColor" opacity="0.5"/>
            <circle cx="20" cy="19" r="2.5" fill="currentColor" opacity="0.7"/>
            <circle cx="26" cy="21" r="1.5" fill="currentColor" opacity="0.5"/>
            <circle cx="11" cy="16" r="2" fill="currentColor" opacity="0.6"/>
            <circle cx="17" cy="14" r="2.5" fill="currentColor" opacity="0.8"/>
            <circle cx="23" cy="15" r="2" fill="currentColor" opacity="0.6"/>
            <circle cx="14" cy="10" r="1.5" fill="currentColor" opacity="0.5"/>
            <circle cx="20" cy="9" r="2" fill="currentColor" opacity="0.6"/>
            <circle cx="16" cy="6" r="1.5" fill="currentColor" opacity="0.4"/>
          </svg>
        </button>

        <div class="nixie-container">
          <div class="nixie-tubes">
            <div class="nixie-tube"><span class="nixie-digit" id="nixie-0">0</span></div>
            <div class="nixie-tube"><span class="nixie-digit" id="nixie-1">0</span></div>
            <div class="nixie-tube"><span class="nixie-digit" id="nixie-2">0</span></div>
            <div class="nixie-tube"><span class="nixie-digit" id="nixie-3">0</span></div>
          </div>
          <span class="nixie-label" data-i18n="volts">Volts</span>
        </div>

        <button class="ionize-btn" id="ionize-btn" data-i18n-title="ionize" title="Ionize (X-ray)">
          <img src="radiation-icon.svg" alt="Ionize" width="32" height="32" style="filter: invert(67%) sepia(54%) saturate(601%) hue-rotate(2deg) brightness(92%) contrast(86%);">
        </button>
      </div>

      <div class="voltage-sliders">
        <div class="fine-slider-container">
          <span class="slider-edge-label">-20</span>
          <div class="fine-slider-track">
            <div class="fine-slider-thumb" id="fine-slider-thumb"></div>
          </div>
          <span class="slider-edge-label">+20</span>
        </div>

        <div class="coarse-slider-container">
          <span class="slider-edge-label">0</span>
          <input type="range" class="coarse-slider" id="coarse-slider" min="0" max="9999" value="0">
          <span class="slider-edge-label">9999</span>
        </div>
      </div>
    </div>
  </main>

  <script>
    // ========== TRANSLATIONS ==========
    const TRANSLATIONS = {
      en: {
        title: "Millikan Oil Drop Experiment",
        description: "Millikan experiment simulation. This is a simplified model of Robert Millikan's experiment (1909–1913).\n\nOil droplets are sprayed between two charged plates. Each droplet carries a small electric charge (a few e). The device allows adjusting the plate separation (d) and droplet mass (m). By varying the voltage, you can balance the gravitational force with the electric field force and calculate the droplet's charge. Radiation can change the droplet's charge, allowing you to balance it again.\n\nMillikan received the Nobel Prize in Physics in 1923 for determining the elementary charge.",
        plateGap: "Plate Gap, mm",
        oilMass: "Oil Mass, ×10⁻¹⁵ kg",
        sprayOil: "Spray Oil",
        ionize: "Ionize (X-ray)",
        volts: "Volts"
      },
      lv: {
        title: "Milikena eļļas pilienu eksperiments",
        description: "Milikena eksperimenta simulācija. Šis ir vienkāršots Roberts Milikena eksperimenta (1909–1913) modelis.\n\nStarp divām uzlādētām plāksnēm tiek izsmidzināti eļļas pilieni. Katram pilienam ir neliels elektriskais lādiņš (daži e). Ierīcē var mainīt attālumu starp plāksnēm (d) un pilienu masu (m). Mainot spriegumu, var līdzsvarot gravitācijas spēku ar elektriskā lauka spēku un aprēķināt piliena lādiņu. Ar starojumu var mainīt piliena lādiņu un līdzsvarot to no jauna.\n\nPar elementārlādiņa noteikšanu Milikens 1923. gadā saņēma Nobela prēmiju fizikā.",
        plateGap: "Plākšņu atstatums, mm",
        oilMass: "Eļļas masa, ×10⁻¹⁵ kg",
        sprayOil: "Izsmidzināt eļļu",
        ionize: "Jonizēt (rentgens)",
        volts: "Volti"
      }
    };

    // ========== LANGUAGE SWITCH ==========
    function getDefaultLang() {
      const saved = localStorage.getItem('physics-sims-lang');
      if (saved) return saved;
      const browserLang = navigator.language.toLowerCase();
      return browserLang.startsWith('lv') ? 'lv' : 'en';
    }

    let currentLang = getDefaultLang();

    function setLanguage(lang) {
      currentLang = lang;
      localStorage.setItem('physics-sims-lang', lang);

      document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.dataset.i18n;
        if (TRANSLATIONS[lang][key]) {
          el.textContent = TRANSLATIONS[lang][key];
        }
      });

      document.querySelectorAll('[data-i18n-title]').forEach(el => {
        const key = el.dataset.i18nTitle;
        if (TRANSLATIONS[lang][key]) {
          el.title = TRANSLATIONS[lang][key];
        }
      });

      if (TRANSLATIONS[lang].title) {
        document.title = TRANSLATIONS[lang].title;
      }

      document.querySelectorAll('.lang-switch button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.lang === lang);
      });

      document.documentElement.lang = lang;
    }

    // ========== CONFIG ==========
    const CONFIG = {
      e: 1.6e-19,              // Elementary charge (C)
      g: 9.81,                 // Gravity (m/s²)
      massValues: [3e-15, 5e-15, 7e-15, 9e-15, 11e-15],  // kg
      dValues: [0.004, 0.006, 0.008, 0.010, 0.012],      // m (4-12 mm)
      maxVoltage: 9999,        // V
      dropletCount: [18, 24],  // min, max per spray
      chargeRange: [0, 10],    // n values
      driftConstant: 4e12,     // Tuned for visible motion (~5s fall time)
      brownianStrength: 1.25,  // Pixel wobble (visible drift, 50% smaller)
      balanceThreshold: 1e-15  // Force threshold for "balanced" (triggers Brownian)
    };

    // Gaussian random using Box-Muller transform
    function gaussianRandom(mean, stdDev) {
      const u1 = Math.random();
      const u2 = Math.random();
      const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
      return mean + z * stdDev;
    }

    // ========== STATE ==========
    let state = {
      mIndex: 1,   // Default: 5e-15 kg
      dIndex: 1,   // Default: 6 mm
      voltage: 0,
      droplets: []
    };

    // ========== CANVAS SETUP ==========
    const canvas = document.getElementById('microscope');
    const ctx = canvas.getContext('2d');
    let canvasSize = 0;

    function resizeCanvas() {
      const container = canvas.parentElement;
      const rect = container.getBoundingClientRect();
      const size = Math.min(rect.width, rect.height) - 30;
      canvasSize = size;
      canvas.width = size * window.devicePixelRatio;
      canvas.height = size * window.devicePixelRatio;
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }

    // ========== PHYSICS ==========
    function createDroplet() {
      const n = Math.floor(Math.random() * (CONFIG.chargeRange[1] - CONFIG.chargeRange[0] + 1)) + CONFIG.chargeRange[0];
      const meanMass = CONFIG.massValues[state.mIndex];
      const mass = gaussianRandom(meanMass, meanMass * 0.05); // ±5% std dev
      return {
        id: Math.random(),
        x: 0.2 + Math.random() * 0.6,  // 20-80% of width
        y: 0.1 + Math.random() * 0.15, // Near top
        n: n,
        q: n * CONFIG.e,
        m: mass,
        brightness: 0.7 + Math.random() * 0.3,
        alive: true,
        // Brownian motion state - each droplet has its own drift tendency
        vx: 0,
        vy: 0
      };
    }

    function sprayDroplets() {
      const count = CONFIG.dropletCount[0] + Math.floor(Math.random() * (CONFIG.dropletCount[1] - CONFIG.dropletCount[0] + 1));
      for (let i = 0; i < count; i++) {
        state.droplets.push(createDroplet());
      }
    }

    function ionizeDroplets() {
      // Random charge changes: -3, -2, -1, +1, +2, +3 (no zero)
      const deltas = [-3, -2, -1, 1, 2, 3];

      state.droplets.forEach(droplet => {
        if (!droplet.alive) return;

        // Random charge change
        const delta = deltas[Math.floor(Math.random() * deltas.length)];
        droplet.n = droplet.n + delta;

        // Clamp minimum to 1 (can't have zero or negative charge)
        if (droplet.n < 1) droplet.n = 1;

        // Recalculate charge
        droplet.q = droplet.n * CONFIG.e;
      });

      // Flash effect
      const container = document.querySelector('.microscope-container');
      container.classList.add('ionize-flash');
      setTimeout(() => container.classList.remove('ionize-flash'), 150);
    }

    function updatePhysics(dt) {
      const d = CONFIG.dValues[state.dIndex];
      const V = state.voltage;
      const E = V / d;

      state.droplets.forEach(droplet => {
        if (!droplet.alive) return;

        const F_electric = droplet.q * E;  // Upward
        const F_gravity = droplet.m * CONFIG.g;     // Downward
        const F_net = F_electric - F_gravity;

        // Velocity proportional to net force
        const v = CONFIG.driftConstant * F_net;

        // Update position (y in normalized coords, negative = up on screen)
        droplet.y -= v * dt;

        // Brownian motion - stronger when near balanced
        const forceRatio = Math.abs(F_net) / F_gravity;
        const brownianScale = forceRatio < 0.05 ? 1.0 : (forceRatio < 0.2 ? 0.6 : 0.15);

        // Random walk with momentum (more natural wandering)
        // Add random impulse to velocity
        droplet.vx += (Math.random() - 0.5) * CONFIG.brownianStrength * brownianScale * dt * 0.5;
        droplet.vy += (Math.random() - 0.5) * CONFIG.brownianStrength * brownianScale * dt * 0.5;

        // Damping - velocities decay over time
        droplet.vx *= 0.95;
        droplet.vy *= 0.95;

        // Apply Brownian velocity to position
        const pixelScale = canvasSize / 400;
        droplet.x += droplet.vx * dt / pixelScale;
        droplet.y += droplet.vy * dt / pixelScale;

        // Check bounds
        if (droplet.y < -0.05 || droplet.y > 1.05) {
          droplet.alive = false;
        }
        if (droplet.x < 0.05 || droplet.x > 0.95) {
          droplet.x = Math.max(0.05, Math.min(0.95, droplet.x));
        }
      });

      // Remove dead droplets
      state.droplets = state.droplets.filter(d => d.alive);
    }

    // ========== RENDERING ==========
    function drawMicroscope() {
      const size = canvasSize;
      const cx = size / 2;
      const cy = size / 2;
      const radius = size / 2 - 2;

      // Clear and clip to circle
      ctx.clearRect(0, 0, size, size);
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.clip();

      // Dark background
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, size, size);

      // Plate indicators (top and bottom)
      const plateHeight = size * 0.03;
      const d = CONFIG.dValues[state.dIndex];
      const plateOffset = (d - 0.004) / 0.008 * size * 0.05; // Slight visual adjustment based on d

      ctx.fillStyle = '#1a1a25';
      ctx.fillRect(0, plateOffset, size, plateHeight);
      ctx.fillRect(0, size - plateHeight - plateOffset, size, plateHeight);

      // Grid lines (reticle) - vertical axis markings
      ctx.strokeStyle = 'rgba(140, 110, 70, 0.6)';
      ctx.lineWidth = 1.5;
      const gridSpacing = size / 10;
      for (let i = 1; i < 10; i++) {
        const y = i * gridSpacing;
        ctx.beginPath();
        // Longer ticks at major divisions (every 2nd line)
        const tickLength = (i % 2 === 0) ? 30 : 15;
        ctx.moveTo(cx - tickLength, y);
        ctx.lineTo(cx + tickLength, y);
        ctx.stroke();
      }

      // Small tick marks on the sides
      ctx.strokeStyle = 'rgba(140, 110, 70, 0.4)';
      ctx.lineWidth = 1;
      for (let i = 1; i < 20; i++) {
        const y = i * (size / 20);
        ctx.beginPath();
        ctx.moveTo(10, y);
        ctx.lineTo(20, y);
        ctx.moveTo(size - 20, y);
        ctx.lineTo(size - 10, y);
        ctx.stroke();
      }

      // Crosshairs
      ctx.strokeStyle = 'rgba(170, 136, 51, 0.6)';
      ctx.lineWidth = 1;
      // Horizontal
      ctx.beginPath();
      ctx.moveTo(0, cy);
      ctx.lineTo(size, cy);
      ctx.stroke();
      // Vertical
      ctx.beginPath();
      ctx.moveTo(cx, 0);
      ctx.lineTo(cx, size);
      ctx.stroke();

      // Droplets
      state.droplets.forEach(droplet => {
        if (!droplet.alive) return;

        const x = droplet.x * size;
        const y = droplet.y * size;
        const baseRadius = 6;

        // Subtle glow - darker
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, baseRadius * 2.5);
        gradient.addColorStop(0, `rgba(180, 140, 50, ${0.35 * droplet.brightness})`);
        gradient.addColorStop(0.5, `rgba(150, 120, 40, ${0.12 * droplet.brightness})`);
        gradient.addColorStop(1, 'rgba(120, 100, 30, 0)');

        ctx.beginPath();
        ctx.arc(x, y, baseRadius * 2.5, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Core - darker, more muted
        ctx.beginPath();
        ctx.arc(x, y, baseRadius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(170, 135, 50, ${0.5 * droplet.brightness})`;
        ctx.fill();
      });

      // Vignette
      const vignetteGradient = ctx.createRadialGradient(cx, cy, radius * 0.5, cx, cy, radius);
      vignetteGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
      vignetteGradient.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
      vignetteGradient.addColorStop(1, 'rgba(0, 0, 0, 0.7)');
      ctx.fillStyle = vignetteGradient;
      ctx.fillRect(0, 0, size, size);

      ctx.restore();
    }

    // ========== UI UPDATES ==========
    function updateKnobRotation(knobId, index, maxIndex) {
      const knob = document.getElementById(knobId);
      const angle = -60 + (index / (maxIndex - 1)) * 120; // -60° to +60°
      knob.style.transform = `rotate(${angle}deg)`;
    }

    function updateReadouts() {
      const d = CONFIG.dValues[state.dIndex] * 1000; // Convert to mm
      const m = CONFIG.massValues[state.mIndex] * 1e15; // Convert to ×10⁻¹⁵ units

      document.getElementById('readout-d').textContent = d.toFixed(0);
      document.getElementById('readout-m').textContent = m.toFixed(1);

      updateKnobRotation('knob-d', state.dIndex, CONFIG.dValues.length);
      updateKnobRotation('knob-m', state.mIndex, CONFIG.massValues.length);
    }

    function updateNixieDisplay(voltage) {
      const v = Math.round(voltage);
      const digits = v.toString().padStart(4, '0').slice(-4);

      for (let i = 0; i < 4; i++) {
        document.getElementById(`nixie-${i}`).textContent = digits[i];
      }
    }

    function clearDroplets() {
      state.droplets = [];
    }

    // ========== EVENT HANDLERS ==========
    document.getElementById('knob-d').addEventListener('click', () => {
      state.dIndex = (state.dIndex + 1) % CONFIG.dValues.length;
      updateReadouts();
      clearDroplets();
    });

    document.getElementById('knob-m').addEventListener('click', () => {
      state.mIndex = (state.mIndex + 1) % CONFIG.massValues.length;
      updateReadouts();
      clearDroplets();
    });

    document.getElementById('spray-btn').addEventListener('click', sprayDroplets);
    document.getElementById('ionize-btn').addEventListener('click', ionizeDroplets);

    // ========== DRAWER CONTROLS ==========
    const drawer = document.getElementById('drawer');
    const drawerOverlay = document.getElementById('drawer-overlay');
    const hamburgerBtn = document.getElementById('hamburger-btn');
    const drawerClose = document.getElementById('drawer-close');

    function openDrawer() {
      drawer.classList.add('open');
      drawerOverlay.classList.add('active');
    }

    function closeDrawer() {
      drawer.classList.remove('open');
      drawerOverlay.classList.remove('active');
    }

    hamburgerBtn.addEventListener('click', openDrawer);
    drawerClose.addEventListener('click', closeDrawer);
    drawerOverlay.addEventListener('click', closeDrawer);

    // ========== COARSE VOLTAGE SLIDER ==========
    const coarseSlider = document.getElementById('coarse-slider');
    coarseSlider.addEventListener('input', (e) => {
      state.voltage = parseFloat(e.target.value);
      updateNixieDisplay(state.voltage);
    });

    // ========== FINE VOLTAGE SLIDER (Spring-return jog) ==========
    const fineTrack = document.querySelector('.fine-slider-track');
    const fineThumb = document.getElementById('fine-slider-thumb');
    let fineActive = false;
    let finePosition = 0; // -1 to +1
    let fineAnimationId = null;
    let fineLastTime = 0;

    function updateFineVoltage(timestamp) {
      if (!fineActive) {
        // Spring return to center
        if (Math.abs(finePosition) > 0.01) {
          finePosition *= 0.85; // Damping
          fineThumb.style.left = `${50 + finePosition * 45}%`;
          fineAnimationId = requestAnimationFrame(updateFineVoltage);
        } else {
          finePosition = 0;
          fineThumb.style.left = '50%';
          fineAnimationId = null;
        }
        return;
      }

      // Calculate dt
      const dt = fineLastTime ? (timestamp - fineLastTime) / 1000 : 0;
      fineLastTime = timestamp;

      // Rate: ±1V/sec at center, ±20V/sec at edges
      const rate = 1 + Math.abs(finePosition) * 19;
      const delta = Math.sign(finePosition) * rate * dt;

      state.voltage = Math.max(0, Math.min(CONFIG.maxVoltage, state.voltage + delta));
      coarseSlider.value = state.voltage;
      updateNixieDisplay(state.voltage);

      fineAnimationId = requestAnimationFrame(updateFineVoltage);
    }

    function startFineDrag(e) {
      e.preventDefault();
      fineActive = true;
      fineThumb.classList.add('dragging');
      fineLastTime = 0;
      updateFinePosition(e);
      if (!fineAnimationId) {
        fineAnimationId = requestAnimationFrame(updateFineVoltage);
      }
    }

    function updateFinePosition(e) {
      const rect = fineTrack.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const x = (clientX - rect.left) / rect.width;
      finePosition = Math.max(-1, Math.min(1, (x - 0.5) * 2));
      fineThumb.style.left = `${50 + finePosition * 45}%`;
    }

    function handleFineMove(e) {
      if (!fineActive) return;
      updateFinePosition(e);
    }

    function endFineDrag() {
      if (!fineActive) return;
      fineActive = false;
      fineThumb.classList.remove('dragging');
      fineLastTime = 0;
      // Spring animation will continue in updateFineVoltage
    }

    fineTrack.addEventListener('mousedown', startFineDrag);
    fineTrack.addEventListener('touchstart', startFineDrag, { passive: false });
    document.addEventListener('mousemove', handleFineMove);
    document.addEventListener('touchmove', handleFineMove, { passive: false });
    document.addEventListener('mouseup', endFineDrag);
    document.addEventListener('touchend', endFineDrag);

    // Touch/drag support for knobs
    let dragStartAngle = 0;
    let dragStartIndex = 0;
    let activeKnob = null;

    function getAngle(element, clientX, clientY) {
      const rect = element.getBoundingClientRect();
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      return Math.atan2(clientY - cy, clientX - cx) * 180 / Math.PI;
    }

    ['knob-d', 'knob-m'].forEach(knobId => {
      const knob = document.getElementById(knobId);

      const startDrag = (e) => {
        e.preventDefault();
        activeKnob = knobId;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        dragStartAngle = getAngle(knob, clientX, clientY);
        dragStartIndex = knobId === 'knob-d' ? state.dIndex : state.mIndex;
      };

      knob.addEventListener('mousedown', startDrag);
      knob.addEventListener('touchstart', startDrag, { passive: false });
    });

    const handleDragMove = (e) => {
      if (!activeKnob) return;

      const knob = document.getElementById(activeKnob);
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const currentAngle = getAngle(knob, clientX, clientY);
      const deltaAngle = currentAngle - dragStartAngle;

      const maxIndex = 4;
      const indexDelta = Math.round(deltaAngle / 30); // 30° per step
      let newIndex = dragStartIndex + indexDelta;
      newIndex = Math.max(0, Math.min(maxIndex, newIndex));

      if (activeKnob === 'knob-d' && newIndex !== state.dIndex) {
        state.dIndex = newIndex;
        updateReadouts();
        clearDroplets();
      } else if (activeKnob === 'knob-m' && newIndex !== state.mIndex) {
        state.mIndex = newIndex;
        updateReadouts();
        clearDroplets();
      }
    };

    const handleDragEnd = () => {
      activeKnob = null;
    };

    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('touchmove', handleDragMove, { passive: false });
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('touchend', handleDragEnd);

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        sprayDroplets();
      } else if (e.code === 'KeyI') {
        e.preventDefault();
        ionizeDroplets();
      } else if (e.code === 'ArrowLeft') {
        e.preventDefault();
        const step = e.shiftKey ? 100 : 10;
        state.voltage = Math.max(0, state.voltage - step);
        coarseSlider.value = state.voltage;
        updateNixieDisplay(state.voltage);
      } else if (e.code === 'ArrowRight') {
        e.preventDefault();
        const step = e.shiftKey ? 100 : 10;
        state.voltage = Math.min(CONFIG.maxVoltage, state.voltage + step);
        coarseSlider.value = state.voltage;
        updateNixieDisplay(state.voltage);
      }
    });

    // ========== MAIN LOOP ==========
    let lastTime = 0;

    function gameLoop(timestamp) {
      const dt = Math.min((timestamp - lastTime) / 1000, 0.05); // Cap dt at 50ms
      lastTime = timestamp;

      updatePhysics(dt);
      drawMicroscope();

      requestAnimationFrame(gameLoop);
    }

    // ========== INIT ==========
    function init() {
      resizeCanvas();
      updateReadouts();
      updateNixieDisplay(0);
      setLanguage(currentLang);
      document.querySelectorAll('.lang-switch button').forEach(btn => {
        btn.addEventListener('click', () => setLanguage(btn.dataset.lang));
      });
      requestAnimationFrame(gameLoop);
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', init);
  </script>
</body>
</html>
